<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[依赖注入]]></title>
    <url>%2Fblog%2F2017-12-21-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html</url>
    <content type="text"><![CDATA[1 前言 这里讨论的目的一直是 解耦 ，实现 高内聚，低耦合 。从最开始的例子一步步抽丝剥茧，逐渐解耦。直至符合 对新增开发，对修改封闭 这一软件设计原则。 这里有几个名词要先预热一下： 依赖倒置原则（DIP） 依赖倒置是面向对象开发领域中的软件设计原则，它倡导上层模块不依赖于底层模块，抽象不依赖细节。良好的面向对象代码设计都要遵从这一原则。 控制反转（Ioc） 依赖反转是遵守依赖倒置这个原则而提出来的一种设计模式，它引入了IoC容器的概念。早在2004年，Martin Fowler就提出了“哪些方面的控制被反转了？”这个问题。他总结出是依赖对象的获得被反转了，因为大多数应用程序都是由两个或是更多的类通过彼此的合作来实现企业逻辑，这使得每个对象都需要获取与其合作的对象（也就是它所依赖的对象）的引用。如果这个获取过程要靠自身实现，那么这将导致代码高度耦合并且难以维护和调试。 依赖注入（DI） 依赖注入是为了实现控制反转的一种手段之一。另外一种是依赖查找。 2 何为依赖 什么是依赖？依赖是一种关系，简单来讲就是需要。比如程序员依赖电脑，电脑被程序员依赖。在面向对象编程中，代码可以这样编写。很简单，就是Coder需要电脑，依赖电脑，有了电脑才能工作。 class Coder { Computer mComputer; public Coder () { mComputer = new Computer(); } public startWork() { mComputer.powerOn(); } } 3 依赖倒置原则 依赖倒置（Dependency inversion principle）是面向对象设计领域的一种软件设计原则。具体描述为 上层模块不应该依赖底层模块，他们都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象 。总结起来就是要面向接口编程。 回到之前Coder和Computer的例子，假如Coder的公司赚钱了，要给所有Coder的电脑都升级为MacComputer。最直接的方案是新增一个MacComputer类。然后在Coder中new MacComputer。 class Coder { // Computer mComputer; MacComputer mMacComputer; public Coder () { // mComputer = new Computer(); mMacComputer = new MacComputer(); } public startWork() { // mComputer.powerOn(); mMacComputer.powerOn(); } } 新增一个MacComputer，改动了三处。明显不符合 对新增开放，对修改关闭 。从划分模块的角度看，这种做法也不符合 依赖倒置原则 。因为Coder属于MacComputer的上层模块。MacComputer为底层模块。存在 上层模块依赖于底层模块 这种情况。 这次，我们对代码做一下改进。新增一个Computable借口，让MacComputer实现Computable接口。Coder中持有一个Computable的实例引用。 public interface Computable { public void powerOn()&#65307; } public class Coder { Computable mComputer; public Coder () { mComputer = new MacComputer(); } public startWork() { mComputer.powerOn(); } } public class MacComputer implements Computable { @Override public void powerOn() { System.out.println("Mac power on"); } } 再看看改版后的代码，比上一版有所改善。假如当公司又上了一个台阶，要给每个Coder配最新版的MacPro。我们只需要新增一个MacProComputer。并且修改实例化代码mComputer = new MacProComputer即可。改动次数由之前的三次，改为一次。虽然很少，仅有一次。并且这一次只体现为 对象实例化 。 public interface Computable { void powerOn()&#65307; } public class Coder { Computable mComputer; public Coder () { // &#21807;&#19968;&#25913;&#21160;&#30340;&#19968;&#22788; mComputer = new MacProComputer(); } public startWork() { mComputer.powerOn(); } } public class MacComputer implements Computable { @Override public void powerOn() { System.out.println("Mac power on"); } } public class MacProComputer implements Computable { @Override public void powerOn() { System.out.println("MacPro power on"); } } 这次，我们消灭掉对象获取的这一处依赖。通过构造函数传参的方式，获取对象实例。不主动new生成实例。当我们要新增一种电脑类型的时候，并不需要改动Coder类中的任何代码。高层模块和底层模块都依赖于抽象接口Computable。所以，这一版设计符合 开闭原则，依赖倒置原则 。 public interface Computable { void powerOn()&#65307; } public class Coder { Computable mComputer; public Coder (Computable computable) { mComputer = computable; } public startWork() { mComputer.powerOn(); } } public class MacComputer implements Computable { @Override public void powerOn() { System.out.println("Mac power on"); } } public class MacProComputer implements Computable { @Override public void powerOn() { System.out.println("MacPro power on"); } } public class Company { public void init() { Coder coder = new Coder(new MacProComputer()); } } 上面的设计称之为 控制反转 。很难理解的一个名词。为什么是反转，对比上一版代码。Coder对于mComputer成员的初始化享有绝对的控制权。因为在Coder中直接new了一个MacProComputer对象，是主动获取。再看看上面的代码，mComputer的获取途径是由构造函数传递进来的参数。Coder是被动获取。所以称之为 控制反转 。丧失了主动控制权。外部负责实例化MacProComputer的类称之为控制反转容器。 事实上，上面的代码展示了基于构造函数的依赖注入达到控制反转的目的。 所以控制反转IoC(Inversion of Control)是说创建对象的控制权进行转移，以前创建对象的主动权和创建时机是由自己把控的，而现在这种权力转移到第三方，比如转移交给了IoC容器，它就是一个专门用来创建对象的工厂，你要什么对象，它就给你什么对象，有了IoC容器，依赖关系就变了，原先的依赖关系就没了，它们都依赖IoC容器了，通过IoC容器来建立它们之间的关系。 4 依赖注入 Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 4.1 基于构造函数的依赖注入 上面的例子已经展示过基于构造函数注入依赖。 4.2 基于set方法的依赖注入 public interface Computable { void powerOn()&#65307; } public class Coder { Computable mComputer; public Coder () { } public void setComputer(Computable computable) { mComputer = computable; } public startWork() { mComputer.powerOn(); } } public class MacComputer implements Computable { @Override public void powerOn() { System.out.println("Mac power on"); } } public class MacProComputer implements Computable { @Override public void powerOn() { System.out.println("MacPro power on"); } } public class Company { public void init() { Coder coder = new Coder(); coder.setComputer(new MacProComputer()); } } 4.3 基于接口的依赖注入 public interface ComputerSetter { void set(Computable computable); } public interface Computable { void powerOn()&#65307; } public class Coder implements ComputerSetter{ Computable mComputer; public Coder () { } @Override public void set(Computable computable){ mComputer = computable; } public void setComputer(Computable computable) { mComputer = computable; } public startWork() { mComputer.powerOn(); } } public class MacComputer implements Computable { @Override public void powerOn() { System.out.println("Mac power on"); } } public class MacProComputer implements Computable { @Override public void powerOn() { System.out.println("MacPro power on"); } } public class Company { public void init() { Coder coder = new Coder(); coder.set(new MacProComputer()); } } 4.4 基于注解的依赖注入 参考Dagger2。 5 Dagger2 为什么会有Dagger2？当我们的代码遵循 开闭原则，依赖倒置等原则之后 。并把对象实例化的权力移交到外部之后，总归有一处地方（称之为注射器，参考以下代码）是要来实例化对象。更为复杂的是注射器中的实例初始化还要依照一定的先后顺序生成对象。Dagger2的出现进一步解放了我们的双手，让我们不必自己去编写注射器代码，只需要依照Dagger2的约定配置。Dagger2会自动生成相应的注射器。会在适当的时候注入。 所以Dagger2本质上是一个依赖注入框架，依赖注入的目的就是为了给需求方在合适的时候注入依赖。 B b = new B(5); C c = new C(110,"110"); D d = new D(110, c); A a = new A(); a.setB(b); a.setC(c); a.setD(d); 前门提到过Dagger2是 基于注解 来实现依赖注入。所以，在使用Dagger2之前，我们需要了解这些注解的含义，如果对注解是什么还不清楚的可以自行Google一下。Dagger2中主要有6种注解。前四种通俗易懂，后两种理解起来就有一定难度了。 5.1 @Inject 用来修饰构造函数的时候，表示提供依赖。用来修饰成员变量，表示需要依赖。该变量由注入框架负责实例化。 5.2 @Module 带有此注解的类，用来提供依赖，里面定义一些用@Provides注解的以provide开头的方法，这些方法就是所提供的依赖，Dagger2会在该类中寻找实例化某个类所需要的依赖。 5.3 @Component 它是一个桥梁，一端是目标类@Inject，另一端是目标类所依赖类的实例@Module，它也是注入器负责把目标类所依赖类的实例注入到目标类中，同时它也管理Module。 5.4 @Provides 修饰方法，表示该方法提供依赖。 5.5 @Qulifier 当某个对象需要注入依赖时，Dagger2就会根据Module中标记了@Provide的方法的返回值来确定由谁为这个变量提供实例。那问题来了，如果有两个一样的返回类型，该用谁呢。我们把这种场景叫做依赖迷失，见名知意，Dagger这时候就不知道用谁来提供依赖，自然就迷失了。所以我们引入了@Qulifier这个东西，通过自定义Qulifier，可以告诉Dagger2去需找具体的依赖提供者。 5.6 @Scope Dagger2可以通过自定义Scope注解，来限定通过Module和Inject方式创建的类的实例的生命周期能够与目标类的生命周期相同。或者可以这样理解：通过自定义Scope注解可以更好的管理创建的类实例的生命周期。（需要自己手动控制，并不是加了@Scope就可以自动与目标类的生命周期一致。比如在Activity的OnCreate和OnDestroy中加入Component的创建和销毁代码，就能实现和Activity目标类生命周期一致。另外@Scope还可以用来实现Component中的局部单例。） 5.7 小结 @Inject和@Module（其中的@Provides）都是属于依赖提供方，含有@Inject标注的成员变量的类属于依赖需求方。@Component属于一个桥梁，把依赖需求方和依赖提供方联系起来。@Qulifier用来解决依赖提供方的依赖迷失，@Scope用来解决实例的创建和声明生命周期。 5.8 注入步骤 查找Module中是否存在创建该类的方法 若存在创建类方法，查看该方法是否存在参数。 若存在参数，则按从 步骤1 开始依次初始化每个参数。 若不存在参数，则直接初始化该类实例，一次依赖注入到此结束。 若不存在创建类方法，则查找Inject注解的构造函数，看构造函数是否存在参数。 若存在参数，则从 步骤1 开始依次初始化每个参数。 若不存在参数，则直接初始化该类实例，一次依赖注入到此结束。 5.9 Component组织方式 5.9.1 为何要划分 假如一个app（app指的是Android app）中只有一个Component，那这个Component是很难维护、并且变化率是很高，很庞大的，就是因为Component的职责太多了导致的。所以就有必要把这个庞大的Component进行划分，划分为粒度小的Component。 5.9.2 以何种粒度划分 要有一个全局的Component(可以叫ApplicationComponent),负责管理整个app的全局类实例（全局类实例整个app都要用到的类的实例，这些类基本都是单例的，后面会用此词代替）。 每个页面对应一个Component，比如一个Activity页面定义一个Component，一个Fragment定义一个Component。当然这不是必须的，有些页面之间的依赖的类是一样的，可以公用一个Component。 5.9.3 为什么需要页面粒度划分 一个app是由很多个页面组成的，从组成app的角度来看一个页面就是一个完整的最小粒度了。 一个页面的实现其实是要依赖各种类的，可以理解成一个页面把各种依赖的类组织起来共同实现一个大的功能，每个页面都组织着自己的需要依赖的类，一个页面就是一堆类的组织者。 划分粒度不能太小了。假如使用mvp架构搭建app，划分粒度是基于每个页面的m、v、p各自定义Component的，那Component的粒度就太小了，定义这么多的Component，管理、维护就很非常困难。 5.9.4 组织Component 依赖方式 一个Component是依赖于一个或多个Component，Component中的dependencies属性就是依赖方式的具体实现。视角在子Component，表明子Component依赖父Component。Component依赖方式只能访问通过Component接口暴露的对象。不能访问父Component的依赖图表。 包含方式 一个Component是包含一个或多个Component的，被包含的Component还可以继续包含其他的Component。这种方式特别像Activity与Fragment的关系。SubComponent就是包含方式的具体实现。视角在父Component，表明父Component包含子Component。SubComponent可以访问父Component的所有依赖图表。 继承方式 官网没有提到该方式，具体没有提到的原因我觉得应该是，该方式不是解决类实例共享的问题，而是从更好的管理、维护Component的角度，把一些Component共有的方法抽象到一个父类中，然后子Component继承。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>dagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本排序算法]]></title>
    <url>%2Fblog%2F2017-01-29-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[1 TODO 排序算法&#xa0;&#xa0;&#xa0;@home&#xa0;ALGORITHM 1.1 性能指标 效率从高到低 常数级 对数级 次线性级 线性级 n log(n) 平方级 指数级 1.2 排序算法 使用环境 小规模数据(因为复杂度为O(n平法)) 原本几乎有序(原本几乎有序,在理想状况下,算法复杂度为O(n)) 1.3 代码实现 def insert_sort(ary): """ &#25554;&#20837;&#27861;&#25490;&#24207; """ """ &#31639;&#27861;&#22797;&#26434;&#24230;O(n&#24179;&#26041;)""" """ &#22987;&#32456;&#20445;&#35777;A[0,i]&#26159;&#26377;&#24207;&#30340; """ """ &#20381;&#27425;&#25554;&#20837;&#20540;,&#22914;&#26524;&#25554;&#20837;&#30340;&#20540;&#27604;&#24038;&#36793;&#30340;&#23567;,&#20381;&#27425;&#24448;&#24038;&#31227;&#21160;&#30452;&#33267;&#21512;&#36866;&#20301;&#32622; """ sort_ary = [0 for i in range(len(ary))] for i in range(len(ary)): sort_ary[i] = ary[i] for j in range(i, 0, -1): if sort_ary[j] &lt; sort_ary[j - 1]: tmp = sort_ary[j - 1] sort_ary[j - 1] = sort_ary[j] sort_ary[j] = tmp for i in range(len(sort_ary)): ary[i] = sort_ary[i] def median_sort(ary): """ &#20013;&#20540;&#27861;&#25490;&#24207; """ """ &#31639;&#27861;&#22797;&#26434;&#24230;O(nlog(n)) """ """ &#36882;&#24402;,&#20998;&#27835;&#24605;&#24819; """ """ &#25214;&#21040;&#20013;&#20540;&#20803;&#32032;,&#27604;&#20013;&#20540;&#23567;&#30340;&#25918;&#24038;&#36793;,&#22823;&#20110;&#25110;&#32773;&#31561;&#20110;&#20013;&#20540;&#30340;&#25918;&#21491;&#36793; """ """ &#36882;&#24402;&#20013;&#20540;&#24038;&#21491;&#23376;&#25968;&#32452; """ median_sort_internal(ary, 0, len(ary) - 1) def median_sort_internal(ary, left, right): """ &#36882;&#24402;&#20989;&#25968; """ if right &lt;= left: return else: mid = (right - left + 1) / 2 select_kth(ary, left, right, mid) median_sort_internal(ary, left, left + mid - 1) median_sort_internal(ary, left + mid + 1, right) def select_kth(ary, left, right, k): """ &#36873;&#25321;&#31532;k&#22823;&#30340;&#20803;&#32032;,&#24182;&#20998;&#21306; """ idx = left index = partition(ary, left, right, idx) if (left + k) - 1 == index: return index else: if (left + k - 1) &lt; index: return select_kth(ary, left, index - 1, k) else: return select_kth(ary, index + 1, right, k - (index - left + 1)) def partition(ary, left, right, index): """ &#20998;&#22359;&#20989;&#25968;,&#24182;&#36820;&#22238;index&#23545;&#24212;&#20540;&#22312;&#20998;&#22359;&#23436;&#25104;&#30340;&#19979;&#26631; """ store = left value = ary[index] tmp = ary[right] ary[right] = value ary[index] = tmp for i in range(left, right, +1): if ary[i] &lt; value: tmp = ary[i] ary[i] = ary[store] ary[store] = tmp store = store + 1 ary[right] = ary[store] ary[store] = value return store def quick_sort(ary, left, right): """ &#24555;&#36895;&#25490;&#24207; """ """ &#24555;&#36895;&#25490;&#24207;&#21644;&#20013;&#20540;&#25490;&#24207;&#30340;&#26041;&#27861;&#20960;&#20046;&#19968;&#26679;,&#21306;&#21035;&#22312;&#20110;&#24555;&#36895;&#25490;&#24207;&#21487;&#20197;&#38543;&#26426;&#36873;&#25321;&#26530;&#32445;&#20540;,&#32780;&#19981;&#26159;&#36873;&#25321;&#20013;&#20540; """ if (left &gt;= right): return """ &#36873;&#25321;&#26368;&#21491;&#36793;&#30340;&#20026;&#26530;&#32445;&#20540; """ key = ary[right] i = left j = left for i in xrange(left, right): if (ary[i] &lt; key): tmp = ary[i] ary[i] = ary[j] ary[j] = tmp j = j + 1 tmp = ary[j] ary[j] = key ary[right] = tmp quick_sort(ary, left, j - 1) quick_sort(ary, j + 1, right) def bubble_sort(ary): """ &#20882;&#27873;&#25490;&#24207; """ """ &#26102;&#38388;&#22797;&#26434;&#24230;O(n&#24179;&#26041;) """ """ &#22914;&#20854;&#21517;,&#20687;&#27668;&#27873;&#19968;&#26679;&#32593;&#19978;&#20882; """ """ &#22914;&#26524;a[i]&#22823;&#20110;a[i+1],&#21017;&#20132;&#25442;.&#38656;&#35201;&#36827;&#34892;n-1&#27425;&#25195;&#25551;. """ """ &#31532;&#19968;&#27425;&#25195;&#25551;&#25226;&#26368;&#22823;&#20540;&#25918;&#21040;&#26368;&#21518;,&#31532;&#20108;&#27425;&#25226;&#31532;&#20108;&#22823;&#30340;&#20540;&#25918;&#21040;&#26368;&#22823;&#20540;&#21069;&#38376;,&#20381;&#27425;&#31867;&#25512; """ length = len(ary) for i in range(length - 1, -1, -1): for j in range(i): if ary[j] &gt; ary[j + 1]: tmp = ary[j] ary[j] = ary[j + 1] ary[j + 1] = tmp def select_sort(ary): """ &#36873;&#25321;&#25490;&#24207; """ """ &#26102;&#38388;&#22797;&#26434;&#24230;O(n&#24179;&#26041;) """ """ &#19981;&#20572;&#36873;&#25321;&#26368;&#22823;&#20540;&#24448;&#26368;&#21518;&#25918;,&#20808;&#36873;&#23436;&#20877;&#20132;&#25442; """ for i in range(len(ary)): index = select_max(ary, len(ary) - i) tmp = ary[len(ary) - i - 1] ary[len(ary) - i - 1] = ary[index] ary[index] = tmp def select_max(ary, length): """ &#36873;&#25321;&#26368;&#22823;&#20540;,&#36820;&#22238;&#19979;&#26631; """ max = ary[length - 1] index = length - 1 for i in range(length): if max &lt; ary[i]: max = ary[i] index = i return index def heap_sort(ary): """ &#22534;&#25490;&#24207; """ """ &#26102;&#38388;&#22797;&#26434;&#24230;O(nlogn),&#26368;&#22351;&#24773;&#20917;&#20063;&#26159;n(nlogn) """ """ &#21487;&#20197;&#25226;&#22534;&#24403;&#20570;&#23436;&#20840;&#20108;&#21449;&#26641; """ """ &#21033;&#29992;&#22534;&#30340;&#24615;&#36136;,&#19981;&#20572;&#28155;&#21152;&#26377;&#24207;&#21306;&#22495;,&#30452;&#33267;&#20840;&#37096;&#26377;&#24207;. """ """ 1. &#26500;&#36896;&#22823;&#39030;&#22534; """ """ 2. &#21462;&#20986;&#26681;&#20803;&#32032;&#21644;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;&#20114;&#25442;. """ """ 3. &#37325;&#22797;&#25191;&#34892;&#20197;&#19978;&#36807;&#31243; """ build_heap(ary) length = len(ary) for i in range(length - 1, -1, -1): tmp = ary[0] ary[0] = ary[i] ary[i] = tmp """ &#22823;&#26681;&#22534;&#26681;&#39030;&#20803;&#32032;&#20114;&#25442;,&#28982;&#21518;&#37325;&#26032;&#26500;&#36896;&#22823;&#26681;&#22534; """ heapify(ary, 0, i) def build_heap(ary): """ &#21021;&#22987;&#21270;&#22534;,&#20174;&#26080;&#24207;&#22534;&#21040;&#22823;&#26681;&#22534; """ """ &#20551;&#35774;&#23436;&#20840;&#20108;&#21449;&#26641;&#30340;&#23618;&#32423;&#20026;n,&#20174;n-1&#23618;&#24320;&#22987;&#26500;&#36896;&#23376;&#22823;&#26681;&#22534;,&#36880;&#28176;&#36882;&#20943;n.&#30452;&#21040;n&#20026;0. """ length = len(ary) / 2 - 1 for i in range(length, -1, -1): heapify(ary, i, len(ary)) def heapify(ary, idx, max_len): """ &#35843;&#25972;&#22534; """ left = 2 * idx + 1 right = 2 * idx + 2 largest = idx if left &lt; max_len and ary[left] &gt; ary[idx]: largest = left if right &lt; max_len and ary[right] &gt; ary[largest]: largest = right if not largest == idx: tmp = ary[idx] ary[idx] = ary[largest] ary[largest] = tmp heapify(ary, largest, max_len) def counting_sort(ary): """ &#35745;&#25968;&#25490;&#24207; """ """ &#38750;&#27604;&#36739;&#25490;&#24207;,&#26102;&#38388;&#22797;&#26434;&#24230;&#20026;&#32447;&#24615;. """ """ &#36866;&#21512;&#20110;&#25490;&#24207;n&#20010;&#20803;&#32032;,&#20803;&#32032;&#30340;&#21462;&#20540;&#20026;[0, k],n&#36828;&#22823;&#20110;k """ k = ary[0] for i in range(len(ary)): if ary[i] &gt; k: k = ary[i] k_ary = [0 for i in range(k + 1)] tmp = 0 for i in range(len(ary)): k_ary[ary[i]] += 1 for i in range(len(k_ary)): if k_ary[i] &gt; 0: for j in range(k_ary[i]): ary[tmp] = i tmp += 1 def bucket_sort(ary): """ &#26742;&#25490;&#24207; """ """ &#36319;&#35745;&#25968;&#25490;&#24207;&#31867;&#20284; """ """ &#20351;&#29992;hash&#20989;&#25968;&#22343;&#21248;&#30340;&#23558;n&#20010;&#20803;&#32032;&#20998;&#25955;&#21040;k&#20010;&#26742;&#20013;,&#26742;&#24517;&#39035;&#26159;&#26377;&#24207;&#30340;,i-1&#26742;&#20013;&#30340;&#20803;&#32032;&#19968;&#23450;&#37117;&#35201;&#27604;i&#26742;&#20013;&#30340;&#20803;&#32032;&#23567; """ """ &#27599;&#20010;&#26742;&#20351;&#29992;&#25554;&#20837;&#25490;&#24207; """ k = ary[0] for i in range(len(ary)): if ary[i] &gt; k: k = ary[i] """ hash(x) = x / 3 """ bucket_ary = [[] for i in range(k / 3 + 1)] for i in range(len(ary)): index = ary[i] / 3 bucket_ary[index].append(ary[i]) tmp = 0 for i in range(len(bucket_ary)): insert_sort(bucket_ary[i]) for j in range(len(bucket_ary[i])): ary[tmp] = bucket_ary[i][j] tmp += 1 ARRAY = [2, 5, 6, 8, 1, 3, 4, 2, 9, 7] insert_sort(ARRAY) print ARRAY ARRAY = [2, 5, 6, 8, 1, 3, 4, 2, 9, 7] quick_sort(ARRAY, 0, len(ARRAY) - 1) print ARRAY ARRAY = [2, 5, 6, 8, 1, 3, 4, 2, 9, 7] median_sort(ARRAY) print ARRAY ARRAY = [2, 5, 6, 8, 1, 3, 4, 2, 9, 7] select_sort(ARRAY) print ARRAY ARRAY = [2, 5, 6, 8, 1, 3, 4, 2, 9, 7] bubble_sort(ARRAY) print ARRAY ARRAY = [2, 5, 6, 8, 1, 3, 4, 2, 9, 7] heap_sort(ARRAY) print ARRAY ARRAY = [2, 5, 6, 8, 1, 3, 4, 2, 9, 7] counting_sort(ARRAY) print ARRAY ARRAY = [2, 5, 6, 8, 1, 3, 4, 2, 9, 7] bucket_sort(ARRAY) print ARRAY]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[九宫格问题]]></title>
    <url>%2Fblog%2F2017-01-29-%E4%B9%9D%E5%AE%AB%E6%A0%BC%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[1 DONE 九宫格问题(幻方)&#xa0;&#xa0;&#xa0;@office&#xa0;ALGORITHM 参考百度百科,幻方法则 奇阶幻方(Loubere法)(link) 奇数阶幻方最经典的填法是罗伯特法(也有人称之为楼梯法).填写方法是这样： 把1(或最小的数)放在第一行正中； 按以下规律排列剩下的n*n-1个数： 每一个数放在前一个数的右上一格； 如果这个数所要放的格已经超出了顶行那么就把它放在底行,仍然要放在右一列； 如果这个数所要放的格已经超出了最右列那么就把它放在最左列,仍然要放在上一行； 如果这个数所要放的格已经超出了顶行且超出了最右列,那么就把它放在前一个数的下一行同一列的格内； 如果这个数所要放的格已经有数填入,处理方法同(4). 单偶阶幻方(Strachey法)(link) 计算 m = (n - 2) / 4 分割成4个奇幻方,左上为A,右下为B,右上为C,左下为D 使用罗伯法分别填充A,B,C,D 在A阵中取左侧m列与D阵对应小格对调,在C阵中取右侧m-1列与B阵对应小格对调(m-1为零不需要对调) 最后在A阵中间行取中心格与左侧一格与D阵对应小格对调 双偶阶幻方(Spring法)(link) 先把数字按顺序填.然后,按n*n把它分割成m*m个小方阵. 每个小方阵对角线上的数字,换成和它互补的数. 代码 def loubere(n, index=1): """ &#22855;&#24187;&#26041;&#27004;&#26799;&#27861; """ """ 1&#23621;&#19978;&#34892;&#27491;&#20013;&#22830; &#20381;&#27425;&#26012;&#22635;&#20999;&#33707;&#24536; &#19978;&#20986;&#26694;&#30028;&#24448;&#19979;&#20889; &#21491;&#20986;&#26694;&#26102;&#24038;&#36793;&#25918; &#37325;&#22797;&#20415;&#22312;&#19979;&#26684;&#22635; &#20986;&#35282;&#37325;&#22797;&#19968;&#20010;&#26679; """ half = n / 2 matrix = [[0 for i in range(n)] for i in range(n)] if n % 2 == 1: formatprint(matrix) matrix[0][half] = index i = 0 j = half formatprint(matrix) for a in range(index + 1, n * n + index): j = j + 1 i = i - 1 if i in range(0, n) and j &gt;= n: j = 0 if i &lt; 0 and j in range(0, n): i = n - 1 if i &lt; 0 and j &gt;= n: i = i + 2 j = j - 1 if matrix[i][j] != 0: i = i + 2 j = j - 1 matrix[i][j] = a formatprint(matrix) else: print "input one odd number" return matrix def spring(n): """ spring&#27861;&#29983;&#25104;&#21452;&#20598;&#38454;&#24187;&#26041; """ """ 1. &#20808;&#25226;&#25968;&#23383;&#25353;&#39034;&#24207;&#22635;.&#28982;&#21518;,&#25353;n*n&#25226;&#23427;&#20998;&#21106;&#25104;m*m&#20010;&#23567;&#26041;&#38453;. """ """ 2. &#27599;&#20010;&#23567;&#26041;&#38453;&#23545;&#35282;&#32447;&#19978;&#30340;&#25968;&#23383;,&#25442;&#25104;&#21644;&#23427;&#20114;&#34917;&#30340;&#25968;. """ matrix = [[x + y * n + 1 for x in range(n)] for y in range(n)] if n % 4 == 0: formatprint(matrix) m = n / 2 sum = n * n + 1 # &#23545;&#35282;&#32447;&#26465;&#20214; # &#34892;&#19979;&#26631; - &#21015;&#19979;&#26631; % m = 0 &#25110;&#32773; &#34892;&#19979;&#26631; + &#21015;&#19979;&#26631; % m = m - 1 for i in range(n): for j in range(n): if (i - j) % m == 0 or (i + j) % m == m - 1: matrix[i][j] = sum - matrix[i][j] formatprint(matrix) formatprint(matrix) else: print "input x = n * 4" return matrix def strachey(n): """ strachey&#27861;&#29983;&#25104;&#21333;&#20598;&#24187;&#26041; """ """ 1. &#35745;&#31639; m = (n - 2) / 4 """ """ 2. &#20998;&#21106;&#25104;4&#20010;&#22855;&#24187;&#26041;,&#24038;&#19978;&#20026;A,&#21491;&#19979;&#20026;B,&#21491;&#19978;&#20026;C,&#24038;&#19979;&#20026;D """ """ 3. &#20351;&#29992;&#32599;&#20271;&#27861;&#20998;&#21035;&#22635;&#20805;A,B,C,D """ """ 4. &#22312;A&#38453;&#20013;&#21462;&#24038;&#20391;m&#21015;&#19982;D&#38453;&#23545;&#24212;&#23567;&#26684;&#23545;&#35843;,&#20013;&#38388;&#34892;&#21462;m-1&#21015;.&#22312;C&#38453;&#20013;&#21462;&#21491;&#20391;m-1&#21015;&#19982;B&#38453;&#23545;&#24212;&#23567;&#26684;&#23545;&#35843;(m-1&#20026;&#38646;&#19981;&#38656;&#35201;&#23545;&#35843;) """ """ 5. &#26368;&#21518;&#22312;A&#38453;&#20013;&#38388;&#34892;&#21462;&#20013;&#24515;&#26684;&#19982;&#24038;&#20391;&#19968;&#26684;&#19982;D&#38453;&#23545;&#24212;&#23567;&#26684;&#23545;&#35843; """ matrix = [[0 for i in range(n)] for i in range(n)] if n % 2 == 0 and not n % 4 == 0: m = n / 4 half = n / 2 A = loubere(half) B = loubere(half, half * half + 1) C = loubere(half, half * half * 2 + 1) D = loubere(half, half * half * 3 + 1) for i in range(half): for j in range(half): if i == j and i == half / 2: tmp = A[i][j] A[i][j] = D[i][j] D[i][j] = tmp if j &lt; m: tmp = A[i][j] A[i][j] = D[i][j] D[i][j] = tmp """ &#20013;&#38388;&#34892;&#21482;&#25442;m-1&#21015;,&#25152;&#20197;&#38656;&#35201;&#25442;&#22238;&#21435; """ if i == half / 2 and j == m - 1: tmp = A[i][j] A[i][j] = D[i][j] D[i][j] = tmp if j &lt; m - 1: tmp = C[i][half - 1 - j] C[i][half - 1 - j] = B[i][half - 1 - j] B[i][half - 1 - j] = tmp for i in range(n): for j in range(n): if i &lt; half and j &lt; half: matrix[i][j] = A[i][j] elif i &lt; half and j &gt;= half: matrix[i][j] = C[i - half][j - half] elif i &gt;= half and j &lt; half: matrix[i][j] = D[i - half][j] else: matrix[i][j] = B[i - half][j - half] formatprint(matrix) else: print "input x = 4m + 2" return matrix def formatprint(array): """ &#26684;&#24335;&#21270;&#36755;&#20986; """ print "--------------------------" for i in array: print i print "--------------------------" def check(matrix): """ &#24187;&#26041;&#26816;&#26597; """ sum = 0 ret = True matrix_lenth = len(matrix) for i in range(matrix_lenth): for j in range(matrix_lenth): sum += matrix[i][j] sum = sum / matrix_lenth for i in range(matrix_lenth): row = 0 col = 0 for j in range(matrix_lenth): row += matrix[i][j] col += matrix[j][i] if not row == sum or not col == sum: ret = False break line1 = 0 line2 = 0 for i in range(matrix_lenth): line1 += matrix[i][i] line2 += matrix[i][matrix_lenth - i - 1] if not line1 == sum or not line2 == sum: ret = False return ret print check(loubere(3)) print check(spring(8)) print check(strachey(10))]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解闭包]]></title>
    <url>%2Fblog%2F2017-01-29-%E7%90%86%E8%A7%A3lisp%E9%97%AD%E5%8C%85.html</url>
    <content type="text"><![CDATA[1 Lambda the Ultimate 理解闭包 闭包定义:如果一个函数返回另一个函数,而被返回函数又需要外层函数的变量时,不会立即释放 这个变量,而是允许被返回的函数引用这些变量.支持这种机制的语言称为支持闭包机制,而这个内 部函数连同其自由变量就形成了一个闭包. (define eq?-c (lambda (a) (lambda (x) (eq? x a)))) 以上eq?-c函数就有一个闭包,首先eq?-c满足一个函数返回另一个函数的条件,eq?-c返回一个lambda函数. lambda函数却引用了外部变量a.所以a为自由变量,lambda函数与自由变量a形成了一个闭包. 再看下面这个例子详细理解一下闭包概念. (define add-a (lambda (a) (lambda (x) (+ x a)))) 这个lambda函数是不完整的,(+ x a)中的a是多少?有两个方法回答这个问题. 第一种叫"动态作用域",a的值决定于函数调用时上下文中a的值. (define a 1) (add-a 1) 以上输出应该为2.因为调用(add-a 1)时,上下文中存在a,并且值为1. 动态作用域的问题是,函数每一次调用相同的参数未必返回相同的值,其返回值还取决于上下文的某些值.这样 的函数具有不确定性. 第二种是"词法作用域",a的值取决于函数定义时上下文中的值. (define fun (add-a 2)) (define a 1) (fun 1) 输出为3.因为定义(lambda (x) (+ x a))时,add-a函数环境中a = 2.所以fun其实的等价(lambda (x) (+ x 2)). 因为fun要"记住"自己定义时a的值为2,所以实现时 (lambda (x) (+ x a))和a = 2 被打包在一块,被称为"闭包",意思是它是完整独立的,仅仅依靠调用时参数求值. 不再依赖调用时的上下文. dynamic scope在每次函数求值的时候都会在这唯一的一个env里查询或更新.而static scope(lexical scope) 是每次函数求值的时候都创建一个新的env,包含了函数定义时候的所能访问到的各种binding.这个新的env连 同那个函数一起.俗称闭包Closure. 词法作用域的函数中遇到既不是形参也不是函数内部定义的局部变量的变量时,去函数定义时的环境中查询. 动态域的函数中遇到既不是形参也不是函数内部定义的局部变量的变量时,到函数调用时的环境中查. 闭包的好处 关于闭包的好处可以看看下面这个例子. (define multi-delete (lambda (test-fun) (lambda (value lat) (cond ((null? lat) (quote ())) ((test-fun (car lat) value) ((multi-delete test-fun) value (cdr lat))) (else (cons (car lat) ((multi-delete test-fun) value (cdr lat)))) )))) ((multi-delete =) 5 '(1 2 3 1 1 5 5 6 7)) ((multi-delete &gt;) 5 '(1 2 3 1 1 5 5 6 7)) ((multi-delete &lt;) 5 '(1 2 3 1 1 5 5 6 7)) ((multi-delete (lambda (x y) (= x (+ y 2)))) 5 '(1 2 3 1 1 5 5 6 7)) ;; =&gt; (1 2 3 1 1 6 7) ;; =&gt; (1 2 3 1 1 5 5) ;; =&gt; (5 5 6 7) 以上函数用来从lat(纯数字list)中删除元素,实现了通用性很强的函数.multi-delete的删除过程 和删除条件分离.这样我们就可以复用multi-delete实现不同条件的删除. again ;; &#21151;&#33021; ;; &#26597;&#35810;lat&#20013;&#30340;&#21407;&#23376;&#26159;&#21542;&#21644;a&#30456;&#31561;,&#22914;&#26524;&#30456;&#31561;&#21017;&#25918;&#20837;ls2,&#19981;&#30456;&#31561;&#21017;&#25918;&#20837;ls1. ;; &#26368;&#21518;&#21028;&#26029;ls2&#26159;&#21542;&#20026;&#31354;. (define multirember&amp;co (lambda (a lat col) (cond ((null? lat) (col (quote ()) (quote ()))) ((eq? (car lat) a) (multirember&amp;co a (cdr lat) (lambda (newlat seen) (col newlat (cons (car lat) seen))))) (else (multirember&amp;co a (cdr lat) (lambda (newlat seen) (col (cons (car lat) newlat) seen))))))) (define a-friend (lambda (x y) (null? y))) 为了便于理解,对以上代码做以下修改. (define multirember&amp;co (lambda (a lat col) (begin (display col) (display "chen\n")) (cond ((null? lat) (col (quote ()) (quote ()))) ((eq? (car lat) a) (multirember&amp;co a (cdr lat) (lambda (newlat seen) (begin (display newlat) (display seen) (display "\n") (col newlat (cons (car lat) seen)))))) (else (multirember&amp;co a (cdr lat) (lambda (newlat seen) (begin (display "&lt;") (display newlat) (display seen) (display "&gt;\n") (col (cons (car lat) newlat) seen)))))))) (define a-friend (lambda (x y) (begin (display "[") (display x) (display y) (display "]\n")))) (multirember&amp;co 'tuna '(strawberries tuna and swordifish) a-friend) ;;&#36755;&#20986; ;;#&lt;procedure (a-friend x y)&gt;chen ;;#&lt;procedure (? newlat seen)&gt;chen ;;#&lt;procedure (? newlat seen)&gt;chen ;;#&lt;procedure (? newlat seen)&gt;chen ;;#&lt;procedure (? newlat seen)&gt;chen ;;&lt;()()&gt; ;;&lt;(swordifish)()&gt; ;;(and swordifish)() ;;&lt;(and swordifish)(tuna)&gt; ;;[(strawberries and swordifish)(tuna)] ;;(multirember&amp;co 'tuna '(strawberries tuna and swordifish) a-friend) lisp递归可以理解成不停地代换至终止条件,然后执行.通过display输出分析,multirember&amp;co 调用了五次,其中第一次为a-friend函数,其余都为lambda表达式.其中lambda是一个闭包,依赖了 外部col参数,所以col为自由变量.参考闭包定义和词法作用域,"词法作用域的函数中遇到既不是 形参也不是函数内部定义的局部变量的变量时,去函数定义时的环境中查询".所以第一次定义 (lambda (newlat seen))时的col为,a-friend函数.第二次以及之后的(lambda (newlat seen)) 中的col同为(lambda (newlat seen)).]]></content>
      <categories>
        <category>lisp</category>
      </categories>
      <tags>
        <tag>lisp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停机问题]]></title>
    <url>%2Fblog%2F2017-01-29-%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[1 停机问题 停机问题wiki 证明过程: 假设存在程序stop?满足以下要求: (stop? prog),如果prog停机返回#t否则返回#f. 定义不停机程序loop (define loop (lambda() (loop))) 构造foo (define foo (lambda() (and (stop? foo) (loop)))) 使用(foo)调用foo程序,首先会对(stop? foo)表达式求值. 假设返回#f(foo不停机),根据and短路求值特性foo程序会直接返回#f从而结束程序(定义说明停机); 假设返回#t(foo停机),则会继续对(loop)求值,(loop)程序会一直运行(定义说明不停机). 两种case都产生矛盾,说明stop?程序不存在.]]></content>
      <categories>
        <category>lisp</category>
      </categories>
      <tags>
        <tag>lisp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android UI 库]]></title>
    <url>%2Fblog%2F2017-01-24-androidlib.html</url>
    <content type="text"><![CDATA[1 android ui lib&#xa0;&#xa0;&#xa0;PERSONAL ui库 TastyToast 炫酷的自定义toast. AdDialog 自定义的广告dialog. Onboarding A beautiful way to introduce users to your app. Android-SpinKit 加载动画库,配备各种加载动画. StickerView A view which can add sticker and zoom,drag,delete it. SlackLoadingView Slack loading animation. RecyclerRefreshLayout A pull to refresh layout for android, the RecyclerRefreshLayout is based on the SwipeRefreshLayout. support all the views, highly customizable, code simplicity, etc ViewPagerCards ViewPager cards. Fresco Facebook open source android picture lib. InstagramLikeColorTransitionAndroid How to create instagram like Gradient color transition in android. AnimShopButton A shopping cart button with a telescopic displacement rotation animation. ViewSpreadTranslationController View Spread TranslationController for Android. Android-SwitchIcon Google launcher-style implementation of switch (enable/disable) icon. PictureSelector Android多图选择器 图片/视频 单选or多选,以及视频录制. Toasty The usual Toast, but with steroids. Hover A floating menu library for Android. 工具库 Sharaku Image filtering UI library like Instagram.]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native开发跨平台应用]]></title>
    <url>%2Fblog%2F2015-12-25-react-first.html</url>
    <content type="text"><![CDATA[1 react-native背景 React Native 结合了 Web 应用和 Native 应用的优势,可以使用 JavaScript 来开发 iOS 和 Android 原生应.在 JavaScript 中用 React 抽象操作系统原生的 UI 组件, 代替 DOM 元素来渲染等. React Native 使你能够使用基于 JavaScript 和 React 一致的开发体验在本地平台 上构建世界一流的应用程序体验.React Native 把重点放在所有开发人员关心的平台 的开发效率上.所以开发者只需学习一种语言就能轻易为任何平台高效地编写代码. 2 安装工具集 requirement version xcode ios 7以上 android android build tool 23.0.1以上 nodejs 4.0以上 react-native 0.1.7 我的机器是osx,所以整个安装过程都用brew进行.安装之前建议先更新一下brew. brew update brew upgrade 安装nodejs mac用户直接去官网下载pkg文件安装.注意nodejs版本要高于4.0. 安装watchman brew install watchman 安装flow brew install flow 安装react-native npm install -g react-native-cli 3 第一个跨平台应用 创建过程可以参考帮助文档1. 所有工具集安装完毕后,创建第一个project吧. react-native init your-project-dir project创建成功后会生成ios和android的project目录,以及两个平台的index入口js 文件. run android device cd your-project react-native run-android 查看日志 adb logcat *:S ReactNative:V ReactNativeJS:V 启动成功 run ios 打开ios目录中的xcodeproj文件.点击run按钮即可. 4 使用组件 react-native提供了丰富的native组件. var React = require('react-native'); var { AppRegistry, StyleSheet, Text, View, TextInput,// add text input component } = React; var TestProject = React.createClass({ render: function() { return ( &lt;View style={styles.container}&gt; &lt;Text style={styles.welcome}&gt; Welcome to React Native! &lt;/Text&gt; &lt;Text style={styles.instructions}&gt; To get started, edit index.android.js &lt;/Text&gt; &lt;Text style={styles.instructions}&gt; Shake or press menu button for dev menu &lt;/Text&gt; // add text input &lt;TextInput style={{height: 40, borderColor: 'gray', borderWidth: 1}} onChangeText={(text) =&gt; this.setState({text})} /&gt; &lt;/View&gt; ); } }); 5 问题 安装react-native报警 如果用nvm管理多个node版本.并且安装提示node版本过低.重新下载pkg安装包.安装 即可. run-android报错 react-native android打包工具要23.0.1以上的版本.解决方法是在sdk manager中 安装高版本android build tool. 启动报错 stackoverflow2上有讨论,我在模拟器上执行adb reverse命令做端口映射即可. adb reverse tcp:8081 tcp:8081 6 总结 总的来说开发方式还是便捷许多.但是存在一个普遍问题.跨平台应用开发的通病-性能. Footnotes: 1 react-native doc https://facebook.github.io/react-native/docs/getting-started.html 2 stackoverflow http://stackoverflow.com/questions/32572399/react-native-android-failed-to-load-js-bundle]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>cross-platform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用hexo搭建个人blog]]></title>
    <url>%2Fblog%2F2015-12-21-buildblogwithhexo.html</url>
    <content type="text"><![CDATA[1 hexo安装 以前陆陆续续用过csdn以及guthub pages写blog.始终没有坚持下来.近两年来一直在 学习eamcs.其中org-mode让我为之倾倒.在工作生活中也都有使用emacs.用过emacs群友 的org-page.但是界面不好看.最后还是放弃.直到遇到hexo和org-octopresss的组合.利 用org-mode进行写作,然后用org-octopress转化成html.搭配hexo的blog框架和漂亮的主 题.一切轻松简单. 关于hexo的介绍可以直接去看文档,开发者是一个台湾人.据说在高中时期就开发了hexo. hexo采用nodejs开发,安装过程和配置都比较简单. npm install -g hexo-cli hexo init &lt;floder&gt; cd &lt;floder&gt; npm install hexo project根目录如下. _config.yml是hexo的站点配置文件,可以配置标题,地区,rss,部署以及评论等功能. # Hexo Configuration ## Docs: http://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: Flysands Blog subtitle: Simple is the best description: Keep life stayreal author: Flysands author_title: 'Programmer &amp; Emacser' avatar: css/images/mylogo.jpg location: 'Chengdu, China' follow: https://github.com/chenxs110/ language: zh-CN timezone: since: 2015 # The start year showing in your copyright section. # URL ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/' url: http://chenxs110.github.com # root: / # permalink: :year/:month/:day/:title/ permalink: blog/:year-:month-:day-:title.html permalink_defaults: # Directory source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true tab_replace: # Category &amp; Tag default_category: uncategorized category_map: tag_map: # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination per_page: 6 pagination_dir: page # Extensions ## Plugins: https://github.com/hexojs/hexo/wiki/Plugins plugins: hexo-generator-feed ## Themes: https://github.com/hexojs/hexo/wiki/Themes theme: icarus # Disqus # disqus_shortname: hexo-theme-icarus # DuoShuo duoshuo_shortname: flysands # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: http://github.com/chenxs110/chenxs110.github.io.git branch: master 2 配置主题 hexo的一大优点,就是有很多漂亮的主题.我选择了icarus.并配置了评论插件多说. 3 github pages搭建静态blog 可以参考github配置自己的blog.然后修改hexo站点中的deploy.注意要安装相应的deployer. 我用的是github.所以只需要安装git deployer即可. # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: http://github.com/chenxs110/chenxs110.github.io.git branch: master 安装deployer. npm install hexo-deployer-git --save 如果需要开启rss订阅,需要安装generate-feed插件. npm install hexo-generator-feed --save 并修改config.yml文件添加generate-feed插件. plugins: hexo-generator-feed 在push到仓库之前,需要先执行hexo generate然后再执行hexo deploy进行部署. 4 emacs org-mode写blog 4.1 七牛云存储&amp;hexo交互 写了几个简单函数用来做文件上传以及hexo交互. (defun chenxuesong-qiniu-upload-img (command) (let ((command-str (format "~/Work/dev-tools/qiniu-devtools/qrsync %s" command))) (shell-command-to-string command-str))) (defun chenxuesong-qiniu-achieve-image () (shell-command-to-string "cp -rf ~/Work/blog/images/* ~/Work/blog/images-achieve") (shell-command-to-string "rm -f ~/Work/blog/images/*")) (defun chenxuesong-hexo-generate (args) (interactive "P") (let ((default-directory chenxueosng-blog-dir)) (shell-command-to-string "hexo generate") (message "hexo generate complete."))) (defun chenxuesong-hexo-deploy (args) (interactive "P") (let ((default-directory chenxueosng-blog-dir)) (chenxuesong-qiniu-upload-img (concat chenxueosng-blog-dir "qiniu.json")) (shell-command-to-string "hexo deploy") (chenxuesong-qiniu-achieve-image) (message "hexo deploy complete."))) (defun chenxuesong-insert-qiniu-link (imagename) (interactive "sImage name: ") (insert (concat (format "[[%s%s]]" "http://7xia6k.com1.z0.glb.clouddn.com/" imagename)))) 4.2 org-octopress org-octopress原本是用来把org转化成适合octopress的html文件.由于hexo兼容 octopress.所以也可以用来生成适用于hexo的html文件. 配置如下: (setq org-blog-dir "~/Work/blog/") (setq org-octopress-directory-top org-blog-dir) (setq org-octopress-directory-posts (concat org-blog-dir "source/_posts")) (setq org-octopress-directory-org-top org-blog-dir) (setq org-octopress-directory-org-posts (concat org-blog-dir "blog")) (setq org-octopress-setup-file (concat org-blog-dir "setupfile.org")) 注意org-posts文件夹不能放到source文件中.否则会生成失败. 4.3 快捷键 添加了几个用于发布和转换html的快捷键. (evil-leader/set-key "oc" 'chenxuesong/org-create-org-blog-file) (evil-leader/set-key "op" 'chenxuesong/org-save-and-export) (evil-leader/set-key "od" 'chenxuesong-hexo-deploy) (evil-leader/set-key "og" 'chenxuesong-hexo-generate) (defun chenxuesong-qiniu-upload-img (command) (let ((command-str (format "~/Work/dev-tools/qiniu-devtools/qrsync %s" command))) (shell-command-to-string command-str))) (defun chenxuesong-qiniu-achieve-image () (shell-command-to-string "cp -rf ~/Work/blog/images/* ~/Work/blog/images-achieve") (shell-command-to-string "rm -f ~/Work/blog/images/*")) (defun chenxuesong-hexo-generate (args) (interactive "P") (let ((default-directory chenxueosng-blog-dir)) (shell-command-to-string "hexo generate") (message "hexo generate complete."))) (defun chenxuesong-hexo-deploy (args) (interactive "P") (let ((default-directory chenxueosng-blog-dir)) (chenxuesong-qiniu-upload-img (concat chenxueosng-blog-dir "qiniu.json")) (shell-command-to-string "hexo deploy") (message "hexo deploy complete.")))]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android指纹模块]]></title>
    <url>%2Fblog%2F2016-01-08-android-fingerprint-module.html</url>
    <content type="text"><![CDATA[Table of Contents 1. android指纹模块流程图 2. android setting指纹模块入口 3. nexus 6p无法启用finger问题原因 1 android指纹模块流程图 Tee : trusted excution env 2 android setting指纹模块入口 主要涉及到一下几个文件 packages/apps/Settings/src/com/android/settings/SecuritySettings.java frameworks/base/core/java/android/hardware/fingerprint/FingerprintManager.java frameworks/base/services/core/java/com/android/server/fingerprint/FingerprintService.java frameworks/base/core/java/android/hardware/fingerprint/IFingerprintDaemon.aidl system/core/fingerprintd/IFingerprintDaemon.cpp system/core/fingerprintd/FingerprintDaemonProxy.cpp hardware/libhardware/hardware.c hardware/libhardware/modules/fingerprint/fingerprint.c 具体流程如下: Settings在做页面展示的时候会调用maybeAddFingerprintPreference函数判断是否 添加fingerprint preference. maybeAddFingerprintPreference内部调用FingerprintManager的isHardwareDetected 函数. FingerprintManager调用FingerprintService中的isHardwareDetected函数. FingerprintService中的isHardwareDetected函数首先进行权限检查,然后如果 mDeviceHalId等于0返回false,表示没有检测到指纹相关的硬件.否则返回ture. mDeviceHalId为底层openHal的返回值. openHal函数的实现非常简单,代码片段如下. int64_t FingerprintDaemonProxy::openHal() { ALOG(LOG_VERBOSE, LOG_TAG, "nativeOpenHal()\n"); int err; const hw_module_t *hw_module = NULL; if (0 != (err = hw_get_module(FINGERPRINT_HARDWARE_MODULE_ID, &amp;hw_module))) { ALOGE("Can't open fingerprint HW Module, error: %d", err); return 0; } if (NULL == hw_module) { ALOGE("No valid fingerprint module"); return 0; } mModule = reinterpret_cast&lt;const fingerprint_module_t *&gt;(hw_module); if (mModule-&gt;common.methods-&gt;open == NULL) { ALOGE("No valid open method"); return 0; } hw_device_t *device = NULL; if (0 != (err = mModule-&gt;common.methods-&gt;open(hw_module, NULL, &amp;device))) { ALOGE("Can't open fingerprint methods, error: %d", err); return 0; } if (kVersion != device-&gt;version) { ALOGE("Wrong fp version. Expected %d, got %d", kVersion, device-&gt;version); // return 0; // FIXME } mDevice = reinterpret_cast&lt;fingerprint_device_t *&gt;(device); err = mDevice-&gt;set_notify(mDevice, hal_notify_callback); if (err &lt; 0) { ALOGE("Failed in call to set_notify(), err=%d", err); return 0; } // Sanity check - remove if (mDevice-&gt;notify != hal_notify_callback) { ALOGE("NOTIFY not set properly: %p != %p", mDevice-&gt;notify, hal_notify_callback); } ALOG(LOG_VERBOSE, LOG_TAG, "fingerprint HAL successfully initialized"); return reinterpret_cast&lt;int64_t&gt;(mDevice); // This is just a handle } openHal函数主要实现以下3个功能 调用hw_get_module加载对应的库文件 调用module结构体的common.methods-&gt;open指向的函数 module结构体定义如下 static struct hw_module_methods_t fingerprint_module_methods = { .open = fingerprint_open, }; fingerprint_module_t HAL_MODULE_INFO_SYM = { .common = { .tag = HARDWARE_MODULE_TAG, .module_api_version = FINGERPRINT_MODULE_API_VERSION_2_0, .hal_api_version = HARDWARE_HAL_API_VERSION, .id = FINGERPRINT_HARDWARE_MODULE_ID, .name = "Emulator Fingerprint HAL", .author = "The Android Open Source Project", .methods = &amp;fingerprint_module_methods, }, }; fingerprint_open函数定义如下 static int fingerprint_open(const hw_module_t *module, const char __unused *id, hw_device_t **device) { if (device == NULL) { ALOGE("NULL device on open"); return -EINVAL; } fingerprint_device_t *dev = malloc(sizeof(fingerprint_device_t)); memset(dev, 0, sizeof(fingerprint_device_t)); dev-&gt;common.tag = HARDWARE_DEVICE_TAG; dev-&gt;common.version = FINGERPRINT_MODULE_API_VERSION_2_0; dev-&gt;common.module = (struct hw_module_t *)module; dev-&gt;common.close = fingerprint_close; dev-&gt;pre_enroll = fingerprint_pre_enroll; dev-&gt;enroll = fingerprint_enroll; dev-&gt;get_authenticator_id = fingerprint_get_auth_id; dev-&gt;cancel = fingerprint_cancel; dev-&gt;remove = fingerprint_remove; dev-&gt;set_active_group = fingerprint_set_active_group; dev-&gt;authenticate = fingerprint_authenticate; dev-&gt;set_notify = set_notify_callback; dev-&gt;notify = NULL; *device = (hw_device_t *)dev; return 0; } 调用set_notify设置回调函数 hw_get_module函数主要实现底层so库加载 具体加载过程可以参考android hw_get_module 分析 hw_get_module内部调用hw_get_module_by_class实现加载过程 /** Base path of the hal modules */ #if defined(__LP64__) #define HAL_LIBRARY_PATH1 "/system/lib64/hw" #define HAL_LIBRARY_PATH2 "/vendor/lib64/hw" #else #define HAL_LIBRARY_PATH1 "/system/lib/hw" #define HAL_LIBRARY_PATH2 "/vendor/lib/hw" #endif /** * There are a set of variant filename for modules. The form of the filename * is "&lt;MODULE_ID&gt;.variant.so" so for the led module the Dream variants * of base "ro.product.board", "ro.board.platform" and "ro.arch" would be: * * led.trout.so * led.msm7k.so * led.ARMV6.so * led.default.so */ static const char *variant_keys[] = { "ro.hardware", /* This goes first so that it can pick up a different file on the emulator. */ "ro.product.board", "ro.board.platform", "ro.arch"}; hw_get_module_by_class根据优先级搜索对应的so文件,文件名主要由两部分构成. 第一部分为模块名,第二部分为类型.其中模块名固定,第二部分优先级顺序为: 硬件 &gt; 产品 &gt; cpu &gt; arch &gt; default. 如果以上函数都执行成功,那么fingerprint module则加载完成. 3 nexus 6p无法启用finger问题原因 清华镜像的源码选择angler product,编译出来的system.img里没有fingerprintd可执行文件. 没有加载fingerprint module对应的库文件. hardware so库加载顺序有误. 解决方法 以移植goldfish为例 拷贝device/generic/goldfish/fingerprint目录到device/huawei/angler目录下 修改device/huawei/angler/device.mk文件,添加fingerprint模块 #Fingerprint PRODUCT_PACKAGES += \ fingerprintd \ fingerprint.msm8994 修改模块加载顺序 由于源码编译出来的image文件,在system/vendor/lib64下含有fingerprint.angler.so. 所以在hw_get_module会加载fingerprint.angler.so而忽略fingerprint.msm8994.so. 所以修改hardware.c文件中的默认搜索顺序,把ro.board.platform放到第一即可. static const char *variant_keys[] = { "ro.board.platform", "ro.hardware", /* This goes first so that it can pick up a different file on the emulator. */ "ro.product.board", // "ro.board.platform", "ro.arch"};]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker compose]]></title>
    <url>%2Fblog%2F2016-01-07-docker-compose.html</url>
    <content type="text"><![CDATA[1 compose docke command test command composess tb link]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Testbird ci 2.0]]></title>
    <url>%2Fblog%2F2016-03-08-testbird-ci-env.html</url>
    <content type="text"><![CDATA[1 Testbird ci 2.0 流程图 2 参与者 TbCli testbird devops开发用于ci过程的项目代码. Gitlab 不多介绍. Jenkins 不多介绍. Registry testbird自建docker registry. Ansible 运维发布工具. Kubernetes 容器编排工具.]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>devops</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建私有registry]]></title>
    <url>%2Fblog%2F2016-03-03-private-registry.html</url>
    <content type="text"><![CDATA[1 背景 2 选型 3 Portus 3.1 下载 git clone https://github.com/SUSE/Portus.git 3.2 初次运行 Portus提供了一个体验版本.compose-setup.sh.简单运行即可. compose-setup.sh -e external-ip 脚本很简单,做了一下几件事情. 检查参数和版本 生成两个config文件(根据template文件生成docker-compose.yml和./compose/registry/config.yml) docker-compose启动数据库,portus_web,crono以及registry 初始化数据库 进入external-ip:3000端口 enjoy it! 3.3 Warning shell提示warning.原来用compose-setup部署的版本只能用于开发或者测试. ########### # WARNING # ########### This deployment method is intended for testing/development purposes. To deploy Portus on production please take a look at: http://port.us.org/documentation.html 总结起来有一下几个问题. registry不支持ssl 没有使用ca机构颁发的证书 数据库以及registry data没有持久化 4 Production部署 部署生产环境的私有registry,需要以下三个模块相辅相成.主要是设置证书和registry以及持久化. 4.1 替换证书 docker-compose.yml指定了registry使用的证书.该证书存放于容器中/etc/docker/registry/目录下. cd Portus mkdir certs cp your-ca.crt xxxx.crt cp your-ca.key xxxx.key xxxx替换为你自己想要定义的名字. 4.2 生成挂载文件夹 cd Portus cd .. mkdir portusdb mkdir registry_data 4.3 Portus web 由于替换了registry使用的证书.所以Portus web也要使用配对的key文件. 在docker-compose.yml中添加环境变量 PORTUS_KEY_PATH. 4.4 Registry 测试版本的部署,没有使用持久化以及tls.持久化需要在docker-compose.yml中配置, tls在./compose/registry/config.yml中配置.配置好的config.yml如下. version: 0.1 storage: filesystem: rootdirectory: /registry_data delete: enabled: true http: addr: 0.0.0.0:5000 debug: addr: 0.0.0.0:5001 tls: certificate: /certs/xxxx.crt key: /certs/xxxx.key auth: token: realm: http:/your-host/registry.testbird.com:3000/v2/token service: your-host:5000 issuer: your-host rootcertbundle: /etc/docker/registry/xxxx.crt notifications: endpoints: - name: portus url: http://your-host:3000/v2/webhooks/events timeout: 500ms threshold: 5 backoff: 1s 4.5 Database 数据库使用mariadb.根据官方文档,持久化储存只需要挂载一个文件夹到容器的/var/lib/mysql 文件夹即可./var/lib/mysql为mariadb的默认db路径.参见docker-compose.yml. 4.6 docker-compose.yml web: image: portus_web command: puma -b tcp://0.0.0.0:3000 -w 3 environment: - PORTUS_MACHINE_FQDN_VALUE=your-host - PORTUS_DB_HOST=portus_db_1 - PORTUS_KEY_PATH=certs/xxxx.key volumes: - .:/portus ports: - 3000:3000 links: - db crono: image: portus_web entrypoint: bin/crono environment: - PORTUS_MACHINE_FQDN=your-host - PORTUS_DB_HOST=portus_db_1 volumes: - .:/portus links: - db db: image: library/mariadb:10.0.23 environment: MYSQL_ROOT_PASSWORD: portus volumes: - ../portusdb:/var/lib/mysql registry: image: library/registry:2.1.1 volumes: - ./certs:/certs - ../registry_data:/registry_data - ./certs/xxxx.crt:/etc/docker/registry/xxxx.crt:ro - ./compose/registry/config.yml:/etc/docker/registry/config.yml:ro ports: - 5000:5000 - 5001:5001 # required to access debug service links: - web 4.7 相关命令 #&#21551;&#21160; cd Portus docker-compose up -d #&#20572;&#27490; docker-compose kill #&#21024;&#38500; docker-compose rm -fv 4.8 初始化数据库 第一次启动后,需要执行两个rake命令初始化数据库. #&#36827;&#20837;web&#23481;&#22120; docker exec -it xxx /bin/sh docker-compose run --rm web rake db:migrate:reset &gt; /dev/null docker-compose run --rm web rake db:seed &gt; /dev/null]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[malawi-cichlids]]></title>
    <url>%2Fblog%2F2016-03-16-malawi-cichlids.html</url>
    <content type="text"><![CDATA[Table of Contents 1. Buccochromis 1.1. Buccochromis spectabilis (新马头) 2. Champsochromis 2.1. Champsochromis caeruleus (酷斯拉) 3. Ctenopharynx 3.1. Ctenopharynx nitidus (金三角) 4. Dimidiochromis 4.1. Dimidiochromis compressiceps (蓝马面) 5. Fossorochromis 5.1. Fossorochromis rostratus (雪花豹) 6. Mylochromis 6.1. Mylochromis ensatus (1280火箭) 6.2. Mylochromis melanotaenia (金斜间) 7. Otopharynx 7.1. Otopharynx heterodon "Tanzanie" (大粒墨) 7.2. Otopharynx lithobates (金头蓝孔雀) 8. Protomelas 8.1. Protomelas fenestratus "Magunga" (史提芬) 8.2. Protomelas taeniolatus (埃及艳后) 9. Placidochromis 9.1. Placidochromis phenochilus (白嘴蓝宝石) 10. Tyrannochromis 10.1. Tyrannochromis macrostoma (大口鲷) 11. Stigmatochromis 11.1. Stigmatochromis woodi (乌帝鹰) 12. Nimbochromis 12.1. Nimbochromis polystigma (芝麻斑) 13. All 14. Reference 学名 中文名 状况 尺寸 价格 公母 品系 数目 Aristochromis christyi 鸟嘴 发色 17-20 200 公 野生 1 Hemitaeniochromis urotaenia 巨人马面 发色 13-15 200 公 野生 1 Aulonocara steveni Chiwindi 蓝黎明 阵亡 10-12 200 公 野生 1 Aulonocara steveni Chiwindi 蓝黎明 阵亡 8-10 60 公 人工 1 Aulonocara steveni Chiwindi 蓝黎明 发色 8-10 80 公 人工 1 Aulonocara baenschi 金松鼠 发色 10-12 70 公 人工 1 Copadichromis borleyi "Mbenji" 波里尔 发色 10-12 200 公 野生 1 Copadichromis trimaculatus 血艳红 发色 8-10 35 公 人工 1 Chilotilapia rhoadesii 帝王鲷 发色 8-10 50 公 人工 1 Buccochromis lepturus 绿马头 良好 8-10 100 公 人工 1 Buccochromis spectabilis 新马头 出售 13-15 520 公 野生 1 Buccochromis spectabilis 新马头 良好 11-13 50 公 人工 1 Buccochromis spectabilis 新马头 良好 8-10 80 公 人工 1 Buccochromis nototaenia 金火令 良好 10-13 100 公 人工 1 Buccochromis nototaenia 金火令 阵亡 8-9 70 公 人工 1 Champsochromis caeruleus 酷斯拉 阵亡 16-18 450 公 野生 1 Copadichromis azureus 金属蓝 良好 10-13 60 公 人工 1 Ctenopharynx nitidus 金三角 良好 13-15 400 公 野生 1 Dimidiochromis compressiceps 蓝马面 阵亡 15-17 100 公 人工 1 Exochochromis anagenys 金鹰 阵亡 6-8 80 公 人工 1 Fossorochromis rostratus 雪花豹 良好 12-13 200 母 野生 1 Fossorochromis rostratus 雪花豹 发色 15-17 330 公 野生 1 Lethrinops Micrentodon Makokola 太阳珍珠 阵亡 5-7 60 公 人工 1 Hemitilapia oxyrhyncha 鸭嘴倒三角 阵亡 13-15 450 公 野生 1 Mylochromis ensatus 1280火箭 阵亡 10-12 288 公 野生 1 Mylochromis melanotaenia 金斜间 阵亡 7-9 200 公 野生 1 Otopharynx heterodon "Tanzanie" 大粒墨 完美 12-13 288 公 野生 1 Otopharynx lithobates 金头蓝孔雀 阵亡 8-9 120 公 德系 1 Protomelas fenestratus "Magunga" 史提芬 阵亡 10-12 260 公 野生 1 Protomelas taeniolatus 埃及艳后 阵亡 13-15 100 公 人工 1 Protomelas taeniolatus 埃及艳后 良好 13-15 0 公 人工 1 Placidochromis phenochilus Mdoka white 白嘴蓝宝石 良好 13-15 150 公 人工 1 Placidochromis phenochilus Mdoka white 白嘴蓝宝石 送人 13-15 150 公 人工 1 Placidochromis phenochilus 蓝宝石 良好 8-9 60 公 人工 1 Tyrannochromis macrostoma 大口鲷 良好 15-17 300 公 野生 1 Tyrannochromis macrostoma "Likoma" 大口鲷 发色 20-22 0 公 野生 1 Stigmatochromis modestus 冇得死 发色 12-15 400 公 野生 1 Stigmatochromis woodi 乌帝鹰 阵亡 13-15 240 公 野生 1 Nimbochromis polystigma 芝麻斑 良好 13-15 400 公 野生 1 &#xa0; &#xa0; &#xa0; &#xa0; 7021 &#xa0; &#xa0; 38 1 Buccochromis 1.1 Buccochromis spectabilis (新马头) 2 Champsochromis 2.1 Champsochromis caeruleus (酷斯拉) 3 Ctenopharynx 3.1 Ctenopharynx nitidus (金三角) 4 Dimidiochromis 4.1 Dimidiochromis compressiceps (蓝马面) 5 Fossorochromis 5.1 Fossorochromis rostratus (雪花豹) 6 Mylochromis 6.1 Mylochromis ensatus (1280火箭) 6.2 Mylochromis melanotaenia (金斜间) 7 Otopharynx 7.1 Otopharynx heterodon "Tanzanie" (大粒墨) 7.2 Otopharynx lithobates (金头蓝孔雀) 8 Protomelas 8.1 Protomelas fenestratus "Magunga" (史提芬) 8.2 Protomelas taeniolatus (埃及艳后) 9 Placidochromis 9.1 Placidochromis phenochilus (白嘴蓝宝石) 10 Tyrannochromis 10.1 Tyrannochromis macrostoma (大口鲷) 11 Stigmatochromis 11.1 Stigmatochromis woodi (乌帝鹰) 12 Nimbochromis 12.1 Nimbochromis polystigma (芝麻斑) 13 All 14 Reference onzemalawicichliden malawi-info malawicichlids]]></content>
      <categories>
        <category>cichlid</category>
      </categories>
      <tags>
        <tag>cichlid</tag>
        <tag>pet</tag>
      </tags>
  </entry>
</search>
