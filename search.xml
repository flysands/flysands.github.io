<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基本排序算法]]></title>
    <url>%2Fblog%2F2017-01-29-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[1 TODO 排序算法&#xa0;&#xa0;&#xa0;@home&#xa0;ALGORITHM 1.1 性能指标 效率从高到低 常数级 对数级 次线性级 线性级 n log(n) 平方级 指数级 1.2 排序算法 使用环境 小规模数据(因为复杂度为O(n平法)) 原本几乎有序(原本几乎有序,在理想状况下,算法复杂度为O(n)) 1.3 代码实现 def insert_sort(ary): """ &#25554;&#20837;&#27861;&#25490;&#24207; """ """ &#31639;&#27861;&#22797;&#26434;&#24230;O(n&#24179;&#26041;)""" """ &#22987;&#32456;&#20445;&#35777;A[0,i]&#26159;&#26377;&#24207;&#30340; """ """ &#20381;&#27425;&#25554;&#20837;&#20540;,&#22914;&#26524;&#25554;&#20837;&#30340;&#20540;&#27604;&#24038;&#36793;&#30340;&#23567;,&#20381;&#27425;&#24448;&#24038;&#31227;&#21160;&#30452;&#33267;&#21512;&#36866;&#20301;&#32622; """ sort_ary = [0 for i in range(len(ary))] for i in range(len(ary)): sort_ary[i] = ary[i] for j in range(i, 0, -1): if sort_ary[j] &lt; sort_ary[j - 1]: tmp = sort_ary[j - 1] sort_ary[j - 1] = sort_ary[j] sort_ary[j] = tmp for i in range(len(sort_ary)): ary[i] = sort_ary[i] def median_sort(ary): """ &#20013;&#20540;&#27861;&#25490;&#24207; """ """ &#31639;&#27861;&#22797;&#26434;&#24230;O(nlog(n)) """ """ &#36882;&#24402;,&#20998;&#27835;&#24605;&#24819; """ """ &#25214;&#21040;&#20013;&#20540;&#20803;&#32032;,&#27604;&#20013;&#20540;&#23567;&#30340;&#25918;&#24038;&#36793;,&#22823;&#20110;&#25110;&#32773;&#31561;&#20110;&#20013;&#20540;&#30340;&#25918;&#21491;&#36793; """ """ &#36882;&#24402;&#20013;&#20540;&#24038;&#21491;&#23376;&#25968;&#32452; """ median_sort_internal(ary, 0, len(ary) - 1) def median_sort_internal(ary, left, right): """ &#36882;&#24402;&#20989;&#25968; """ if right &lt;= left: return else: mid = (right - left + 1) / 2 select_kth(ary, left, right, mid) median_sort_internal(ary, left, left + mid - 1) median_sort_internal(ary, left + mid + 1, right) def select_kth(ary, left, right, k): """ &#36873;&#25321;&#31532;k&#22823;&#30340;&#20803;&#32032;,&#24182;&#20998;&#21306; """ idx = left index = partition(ary, left, right, idx) if (left + k) - 1 == index: return index else: if (left + k - 1) &lt; index: return select_kth(ary, left, index - 1, k) else: return select_kth(ary, index + 1, right, k - (index - left + 1)) def partition(ary, left, right, index): """ &#20998;&#22359;&#20989;&#25968;,&#24182;&#36820;&#22238;index&#23545;&#24212;&#20540;&#22312;&#20998;&#22359;&#23436;&#25104;&#30340;&#19979;&#26631; """ store = left value = ary[index] tmp = ary[right] ary[right] = value ary[index] = tmp for i in range(left, right, +1): if ary[i] &lt; value: tmp = ary[i] ary[i] = ary[store] ary[store] = tmp store = store + 1 ary[right] = ary[store] ary[store] = value return store def quick_sort(ary, left, right): """ &#24555;&#36895;&#25490;&#24207; """ """ &#24555;&#36895;&#25490;&#24207;&#21644;&#20013;&#20540;&#25490;&#24207;&#30340;&#26041;&#27861;&#20960;&#20046;&#19968;&#26679;,&#21306;&#21035;&#22312;&#20110;&#24555;&#36895;&#25490;&#24207;&#21487;&#20197;&#38543;&#26426;&#36873;&#25321;&#26530;&#32445;&#20540;,&#32780;&#19981;&#26159;&#36873;&#25321;&#20013;&#20540; """ if (left &gt;= right): return """ &#36873;&#25321;&#26368;&#21491;&#36793;&#30340;&#20026;&#26530;&#32445;&#20540; """ key = ary[right] i = left j = left for i in xrange(left, right): if (ary[i] &lt; key): tmp = ary[i] ary[i] = ary[j] ary[j] = tmp j = j + 1 tmp = ary[j] ary[j] = key ary[right] = tmp quick_sort(ary, left, j - 1) quick_sort(ary, j + 1, right) def bubble_sort(ary): """ &#20882;&#27873;&#25490;&#24207; """ """ &#26102;&#38388;&#22797;&#26434;&#24230;O(n&#24179;&#26041;) """ """ &#22914;&#20854;&#21517;,&#20687;&#27668;&#27873;&#19968;&#26679;&#32593;&#19978;&#20882; """ """ &#22914;&#26524;a[i]&#22823;&#20110;a[i+1],&#21017;&#20132;&#25442;.&#38656;&#35201;&#36827;&#34892;n-1&#27425;&#25195;&#25551;. """ """ &#31532;&#19968;&#27425;&#25195;&#25551;&#25226;&#26368;&#22823;&#20540;&#25918;&#21040;&#26368;&#21518;,&#31532;&#20108;&#27425;&#25226;&#31532;&#20108;&#22823;&#30340;&#20540;&#25918;&#21040;&#26368;&#22823;&#20540;&#21069;&#38376;,&#20381;&#27425;&#31867;&#25512; """ length = len(ary) for i in range(length - 1, -1, -1): for j in range(i): if ary[j] &gt; ary[j + 1]: tmp = ary[j] ary[j] = ary[j + 1] ary[j + 1] = tmp def select_sort(ary): """ &#36873;&#25321;&#25490;&#24207; """ """ &#26102;&#38388;&#22797;&#26434;&#24230;O(n&#24179;&#26041;) """ """ &#19981;&#20572;&#36873;&#25321;&#26368;&#22823;&#20540;&#24448;&#26368;&#21518;&#25918;,&#20808;&#36873;&#23436;&#20877;&#20132;&#25442; """ for i in range(len(ary)): index = select_max(ary, len(ary) - i) tmp = ary[len(ary) - i - 1] ary[len(ary) - i - 1] = ary[index] ary[index] = tmp def select_max(ary, length): """ &#36873;&#25321;&#26368;&#22823;&#20540;,&#36820;&#22238;&#19979;&#26631; """ max = ary[length - 1] index = length - 1 for i in range(length): if max &lt; ary[i]: max = ary[i] index = i return index def heap_sort(ary): """ &#22534;&#25490;&#24207; """ """ &#26102;&#38388;&#22797;&#26434;&#24230;O(nlogn),&#26368;&#22351;&#24773;&#20917;&#20063;&#26159;n(nlogn) """ """ &#21487;&#20197;&#25226;&#22534;&#24403;&#20570;&#23436;&#20840;&#20108;&#21449;&#26641; """ """ &#21033;&#29992;&#22534;&#30340;&#24615;&#36136;,&#19981;&#20572;&#28155;&#21152;&#26377;&#24207;&#21306;&#22495;,&#30452;&#33267;&#20840;&#37096;&#26377;&#24207;. """ """ 1. &#26500;&#36896;&#22823;&#39030;&#22534; """ """ 2. &#21462;&#20986;&#26681;&#20803;&#32032;&#21644;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;&#20114;&#25442;. """ """ 3. &#37325;&#22797;&#25191;&#34892;&#20197;&#19978;&#36807;&#31243; """ build_heap(ary) length = len(ary) for i in range(length - 1, -1, -1): tmp = ary[0] ary[0] = ary[i] ary[i] = tmp """ &#22823;&#26681;&#22534;&#26681;&#39030;&#20803;&#32032;&#20114;&#25442;,&#28982;&#21518;&#37325;&#26032;&#26500;&#36896;&#22823;&#26681;&#22534; """ heapify(ary, 0, i) def build_heap(ary): """ &#21021;&#22987;&#21270;&#22534;,&#20174;&#26080;&#24207;&#22534;&#21040;&#22823;&#26681;&#22534; """ """ &#20551;&#35774;&#23436;&#20840;&#20108;&#21449;&#26641;&#30340;&#23618;&#32423;&#20026;n,&#20174;n-1&#23618;&#24320;&#22987;&#26500;&#36896;&#23376;&#22823;&#26681;&#22534;,&#36880;&#28176;&#36882;&#20943;n.&#30452;&#21040;n&#20026;0. """ length = len(ary) / 2 - 1 for i in range(length, -1, -1): heapify(ary, i, len(ary)) def heapify(ary, idx, max_len): """ &#35843;&#25972;&#22534; """ left = 2 * idx + 1 right = 2 * idx + 2 largest = idx if left &lt; max_len and ary[left] &gt; ary[idx]: largest = left if right &lt; max_len and ary[right] &gt; ary[largest]: largest = right if not largest == idx: tmp = ary[idx] ary[idx] = ary[largest] ary[largest] = tmp heapify(ary, largest, max_len) def counting_sort(ary): """ &#35745;&#25968;&#25490;&#24207; """ """ &#38750;&#27604;&#36739;&#25490;&#24207;,&#26102;&#38388;&#22797;&#26434;&#24230;&#20026;&#32447;&#24615;. """ """ &#36866;&#21512;&#20110;&#25490;&#24207;n&#20010;&#20803;&#32032;,&#20803;&#32032;&#30340;&#21462;&#20540;&#20026;[0, k],n&#36828;&#22823;&#20110;k """ k = ary[0] for i in range(len(ary)): if ary[i] &gt; k: k = ary[i] k_ary = [0 for i in range(k + 1)] tmp = 0 for i in range(len(ary)): k_ary[ary[i]] += 1 for i in range(len(k_ary)): if k_ary[i] &gt; 0: for j in range(k_ary[i]): ary[tmp] = i tmp += 1 def bucket_sort(ary): """ &#26742;&#25490;&#24207; """ """ &#36319;&#35745;&#25968;&#25490;&#24207;&#31867;&#20284; """ """ &#20351;&#29992;hash&#20989;&#25968;&#22343;&#21248;&#30340;&#23558;n&#20010;&#20803;&#32032;&#20998;&#25955;&#21040;k&#20010;&#26742;&#20013;,&#26742;&#24517;&#39035;&#26159;&#26377;&#24207;&#30340;,i-1&#26742;&#20013;&#30340;&#20803;&#32032;&#19968;&#23450;&#37117;&#35201;&#27604;i&#26742;&#20013;&#30340;&#20803;&#32032;&#23567; """ """ &#27599;&#20010;&#26742;&#20351;&#29992;&#25554;&#20837;&#25490;&#24207; """ k = ary[0] for i in range(len(ary)): if ary[i] &gt; k: k = ary[i] """ hash(x) = x / 3 """ bucket_ary = [[] for i in range(k / 3 + 1)] for i in range(len(ary)): index = ary[i] / 3 bucket_ary[index].append(ary[i]) tmp = 0 for i in range(len(bucket_ary)): insert_sort(bucket_ary[i]) for j in range(len(bucket_ary[i])): ary[tmp] = bucket_ary[i][j] tmp += 1 ARRAY = [2, 5, 6, 8, 1, 3, 4, 2, 9, 7] insert_sort(ARRAY) print ARRAY ARRAY = [2, 5, 6, 8, 1, 3, 4, 2, 9, 7] quick_sort(ARRAY, 0, len(ARRAY) - 1) print ARRAY ARRAY = [2, 5, 6, 8, 1, 3, 4, 2, 9, 7] median_sort(ARRAY) print ARRAY ARRAY = [2, 5, 6, 8, 1, 3, 4, 2, 9, 7] select_sort(ARRAY) print ARRAY ARRAY = [2, 5, 6, 8, 1, 3, 4, 2, 9, 7] bubble_sort(ARRAY) print ARRAY ARRAY = [2, 5, 6, 8, 1, 3, 4, 2, 9, 7] heap_sort(ARRAY) print ARRAY ARRAY = [2, 5, 6, 8, 1, 3, 4, 2, 9, 7] counting_sort(ARRAY) print ARRAY ARRAY = [2, 5, 6, 8, 1, 3, 4, 2, 9, 7] bucket_sort(ARRAY) print ARRAY]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[九宫格问题]]></title>
    <url>%2Fblog%2F2017-01-29-%E4%B9%9D%E5%AE%AB%E6%A0%BC%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[1 DONE 九宫格问题(幻方)&#xa0;&#xa0;&#xa0;@office&#xa0;ALGORITHM 参考百度百科,幻方法则 奇阶幻方(Loubere法)(link) 奇数阶幻方最经典的填法是罗伯特法(也有人称之为楼梯法).填写方法是这样： 把1(或最小的数)放在第一行正中； 按以下规律排列剩下的n*n-1个数： 每一个数放在前一个数的右上一格； 如果这个数所要放的格已经超出了顶行那么就把它放在底行,仍然要放在右一列； 如果这个数所要放的格已经超出了最右列那么就把它放在最左列,仍然要放在上一行； 如果这个数所要放的格已经超出了顶行且超出了最右列,那么就把它放在前一个数的下一行同一列的格内； 如果这个数所要放的格已经有数填入,处理方法同(4). 单偶阶幻方(Strachey法)(link) 计算 m = (n - 2) / 4 分割成4个奇幻方,左上为A,右下为B,右上为C,左下为D 使用罗伯法分别填充A,B,C,D 在A阵中取左侧m列与D阵对应小格对调,在C阵中取右侧m-1列与B阵对应小格对调(m-1为零不需要对调) 最后在A阵中间行取中心格与左侧一格与D阵对应小格对调 双偶阶幻方(Spring法)(link) 先把数字按顺序填.然后,按n*n把它分割成m*m个小方阵. 每个小方阵对角线上的数字,换成和它互补的数. 代码 def loubere(n, index=1): """ &#22855;&#24187;&#26041;&#27004;&#26799;&#27861; """ """ 1&#23621;&#19978;&#34892;&#27491;&#20013;&#22830; &#20381;&#27425;&#26012;&#22635;&#20999;&#33707;&#24536; &#19978;&#20986;&#26694;&#30028;&#24448;&#19979;&#20889; &#21491;&#20986;&#26694;&#26102;&#24038;&#36793;&#25918; &#37325;&#22797;&#20415;&#22312;&#19979;&#26684;&#22635; &#20986;&#35282;&#37325;&#22797;&#19968;&#20010;&#26679; """ half = n / 2 matrix = [[0 for i in range(n)] for i in range(n)] if n % 2 == 1: formatprint(matrix) matrix[0][half] = index i = 0 j = half formatprint(matrix) for a in range(index + 1, n * n + index): j = j + 1 i = i - 1 if i in range(0, n) and j &gt;= n: j = 0 if i &lt; 0 and j in range(0, n): i = n - 1 if i &lt; 0 and j &gt;= n: i = i + 2 j = j - 1 if matrix[i][j] != 0: i = i + 2 j = j - 1 matrix[i][j] = a formatprint(matrix) else: print "input one odd number" return matrix def spring(n): """ spring&#27861;&#29983;&#25104;&#21452;&#20598;&#38454;&#24187;&#26041; """ """ 1. &#20808;&#25226;&#25968;&#23383;&#25353;&#39034;&#24207;&#22635;.&#28982;&#21518;,&#25353;n*n&#25226;&#23427;&#20998;&#21106;&#25104;m*m&#20010;&#23567;&#26041;&#38453;. """ """ 2. &#27599;&#20010;&#23567;&#26041;&#38453;&#23545;&#35282;&#32447;&#19978;&#30340;&#25968;&#23383;,&#25442;&#25104;&#21644;&#23427;&#20114;&#34917;&#30340;&#25968;. """ matrix = [[x + y * n + 1 for x in range(n)] for y in range(n)] if n % 4 == 0: formatprint(matrix) m = n / 2 sum = n * n + 1 # &#23545;&#35282;&#32447;&#26465;&#20214; # &#34892;&#19979;&#26631; - &#21015;&#19979;&#26631; % m = 0 &#25110;&#32773; &#34892;&#19979;&#26631; + &#21015;&#19979;&#26631; % m = m - 1 for i in range(n): for j in range(n): if (i - j) % m == 0 or (i + j) % m == m - 1: matrix[i][j] = sum - matrix[i][j] formatprint(matrix) formatprint(matrix) else: print "input x = n * 4" return matrix def strachey(n): """ strachey&#27861;&#29983;&#25104;&#21333;&#20598;&#24187;&#26041; """ """ 1. &#35745;&#31639; m = (n - 2) / 4 """ """ 2. &#20998;&#21106;&#25104;4&#20010;&#22855;&#24187;&#26041;,&#24038;&#19978;&#20026;A,&#21491;&#19979;&#20026;B,&#21491;&#19978;&#20026;C,&#24038;&#19979;&#20026;D """ """ 3. &#20351;&#29992;&#32599;&#20271;&#27861;&#20998;&#21035;&#22635;&#20805;A,B,C,D """ """ 4. &#22312;A&#38453;&#20013;&#21462;&#24038;&#20391;m&#21015;&#19982;D&#38453;&#23545;&#24212;&#23567;&#26684;&#23545;&#35843;,&#20013;&#38388;&#34892;&#21462;m-1&#21015;.&#22312;C&#38453;&#20013;&#21462;&#21491;&#20391;m-1&#21015;&#19982;B&#38453;&#23545;&#24212;&#23567;&#26684;&#23545;&#35843;(m-1&#20026;&#38646;&#19981;&#38656;&#35201;&#23545;&#35843;) """ """ 5. &#26368;&#21518;&#22312;A&#38453;&#20013;&#38388;&#34892;&#21462;&#20013;&#24515;&#26684;&#19982;&#24038;&#20391;&#19968;&#26684;&#19982;D&#38453;&#23545;&#24212;&#23567;&#26684;&#23545;&#35843; """ matrix = [[0 for i in range(n)] for i in range(n)] if n % 2 == 0 and not n % 4 == 0: m = n / 4 half = n / 2 A = loubere(half) B = loubere(half, half * half + 1) C = loubere(half, half * half * 2 + 1) D = loubere(half, half * half * 3 + 1) for i in range(half): for j in range(half): if i == j and i == half / 2: tmp = A[i][j] A[i][j] = D[i][j] D[i][j] = tmp if j &lt; m: tmp = A[i][j] A[i][j] = D[i][j] D[i][j] = tmp """ &#20013;&#38388;&#34892;&#21482;&#25442;m-1&#21015;,&#25152;&#20197;&#38656;&#35201;&#25442;&#22238;&#21435; """ if i == half / 2 and j == m - 1: tmp = A[i][j] A[i][j] = D[i][j] D[i][j] = tmp if j &lt; m - 1: tmp = C[i][half - 1 - j] C[i][half - 1 - j] = B[i][half - 1 - j] B[i][half - 1 - j] = tmp for i in range(n): for j in range(n): if i &lt; half and j &lt; half: matrix[i][j] = A[i][j] elif i &lt; half and j &gt;= half: matrix[i][j] = C[i - half][j - half] elif i &gt;= half and j &lt; half: matrix[i][j] = D[i - half][j] else: matrix[i][j] = B[i - half][j - half] formatprint(matrix) else: print "input x = 4m + 2" return matrix def formatprint(array): """ &#26684;&#24335;&#21270;&#36755;&#20986; """ print "--------------------------" for i in array: print i print "--------------------------" def check(matrix): """ &#24187;&#26041;&#26816;&#26597; """ sum = 0 ret = True matrix_lenth = len(matrix) for i in range(matrix_lenth): for j in range(matrix_lenth): sum += matrix[i][j] sum = sum / matrix_lenth for i in range(matrix_lenth): row = 0 col = 0 for j in range(matrix_lenth): row += matrix[i][j] col += matrix[j][i] if not row == sum or not col == sum: ret = False break line1 = 0 line2 = 0 for i in range(matrix_lenth): line1 += matrix[i][i] line2 += matrix[i][matrix_lenth - i - 1] if not line1 == sum or not line2 == sum: ret = False return ret print check(loubere(3)) print check(spring(8)) print check(strachey(10))]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解闭包]]></title>
    <url>%2Fblog%2F2017-01-29-%E7%90%86%E8%A7%A3lisp%E9%97%AD%E5%8C%85.html</url>
    <content type="text"><![CDATA[1 Lambda the Ultimate 理解闭包 闭包定义:如果一个函数返回另一个函数,而被返回函数又需要外层函数的变量时,不会立即释放 这个变量,而是允许被返回的函数引用这些变量.支持这种机制的语言称为支持闭包机制,而这个内 部函数连同其自由变量就形成了一个闭包. (define eq?-c (lambda (a) (lambda (x) (eq? x a)))) 以上eq?-c函数就有一个闭包,首先eq?-c满足一个函数返回另一个函数的条件,eq?-c返回一个lambda函数. lambda函数却引用了外部变量a.所以a为自由变量,lambda函数与自由变量a形成了一个闭包. 再看下面这个例子详细理解一下闭包概念. (define add-a (lambda (a) (lambda (x) (+ x a)))) 这个lambda函数是不完整的,(+ x a)中的a是多少?有两个方法回答这个问题. 第一种叫"动态作用域",a的值决定于函数调用时上下文中a的值. (define a 1) (add-a 1) 以上输出应该为2.因为调用(add-a 1)时,上下文中存在a,并且值为1. 动态作用域的问题是,函数每一次调用相同的参数未必返回相同的值,其返回值还取决于上下文的某些值.这样 的函数具有不确定性. 第二种是"词法作用域",a的值取决于函数定义时上下文中的值. (define fun (add-a 2)) (define a 1) (fun 1) 输出为3.因为定义(lambda (x) (+ x a))时,add-a函数环境中a = 2.所以fun其实的等价(lambda (x) (+ x 2)). 因为fun要"记住"自己定义时a的值为2,所以实现时 (lambda (x) (+ x a))和a = 2 被打包在一块,被称为"闭包",意思是它是完整独立的,仅仅依靠调用时参数求值. 不再依赖调用时的上下文. dynamic scope在每次函数求值的时候都会在这唯一的一个env里查询或更新.而static scope(lexical scope) 是每次函数求值的时候都创建一个新的env,包含了函数定义时候的所能访问到的各种binding.这个新的env连 同那个函数一起.俗称闭包Closure. 词法作用域的函数中遇到既不是形参也不是函数内部定义的局部变量的变量时,去函数定义时的环境中查询. 动态域的函数中遇到既不是形参也不是函数内部定义的局部变量的变量时,到函数调用时的环境中查. 闭包的好处 关于闭包的好处可以看看下面这个例子. (define multi-delete (lambda (test-fun) (lambda (value lat) (cond ((null? lat) (quote ())) ((test-fun (car lat) value) ((multi-delete test-fun) value (cdr lat))) (else (cons (car lat) ((multi-delete test-fun) value (cdr lat)))) )))) ((multi-delete =) 5 '(1 2 3 1 1 5 5 6 7)) ((multi-delete &gt;) 5 '(1 2 3 1 1 5 5 6 7)) ((multi-delete &lt;) 5 '(1 2 3 1 1 5 5 6 7)) ((multi-delete (lambda (x y) (= x (+ y 2)))) 5 '(1 2 3 1 1 5 5 6 7)) ;; =&gt; (1 2 3 1 1 6 7) ;; =&gt; (1 2 3 1 1 5 5) ;; =&gt; (5 5 6 7) 以上函数用来从lat(纯数字list)中删除元素,实现了通用性很强的函数.multi-delete的删除过程 和删除条件分离.这样我们就可以复用multi-delete实现不同条件的删除. again ;; &#21151;&#33021; ;; &#26597;&#35810;lat&#20013;&#30340;&#21407;&#23376;&#26159;&#21542;&#21644;a&#30456;&#31561;,&#22914;&#26524;&#30456;&#31561;&#21017;&#25918;&#20837;ls2,&#19981;&#30456;&#31561;&#21017;&#25918;&#20837;ls1. ;; &#26368;&#21518;&#21028;&#26029;ls2&#26159;&#21542;&#20026;&#31354;. (define multirember&amp;co (lambda (a lat col) (cond ((null? lat) (col (quote ()) (quote ()))) ((eq? (car lat) a) (multirember&amp;co a (cdr lat) (lambda (newlat seen) (col newlat (cons (car lat) seen))))) (else (multirember&amp;co a (cdr lat) (lambda (newlat seen) (col (cons (car lat) newlat) seen))))))) (define a-friend (lambda (x y) (null? y))) 为了便于理解,对以上代码做以下修改. (define multirember&amp;co (lambda (a lat col) (begin (display col) (display "chen\n")) (cond ((null? lat) (col (quote ()) (quote ()))) ((eq? (car lat) a) (multirember&amp;co a (cdr lat) (lambda (newlat seen) (begin (display newlat) (display seen) (display "\n") (col newlat (cons (car lat) seen)))))) (else (multirember&amp;co a (cdr lat) (lambda (newlat seen) (begin (display "&lt;") (display newlat) (display seen) (display "&gt;\n") (col (cons (car lat) newlat) seen)))))))) (define a-friend (lambda (x y) (begin (display "[") (display x) (display y) (display "]\n")))) (multirember&amp;co 'tuna '(strawberries tuna and swordifish) a-friend) ;;&#36755;&#20986; ;;#&lt;procedure (a-friend x y)&gt;chen ;;#&lt;procedure (? newlat seen)&gt;chen ;;#&lt;procedure (? newlat seen)&gt;chen ;;#&lt;procedure (? newlat seen)&gt;chen ;;#&lt;procedure (? newlat seen)&gt;chen ;;&lt;()()&gt; ;;&lt;(swordifish)()&gt; ;;(and swordifish)() ;;&lt;(and swordifish)(tuna)&gt; ;;[(strawberries and swordifish)(tuna)] ;;(multirember&amp;co 'tuna '(strawberries tuna and swordifish) a-friend) lisp递归可以理解成不停地代换至终止条件,然后执行.通过display输出分析,multirember&amp;co 调用了五次,其中第一次为a-friend函数,其余都为lambda表达式.其中lambda是一个闭包,依赖了 外部col参数,所以col为自由变量.参考闭包定义和词法作用域,"词法作用域的函数中遇到既不是 形参也不是函数内部定义的局部变量的变量时,去函数定义时的环境中查询".所以第一次定义 (lambda (newlat seen))时的col为,a-friend函数.第二次以及之后的(lambda (newlat seen)) 中的col同为(lambda (newlat seen)).]]></content>
      <categories>
        <category>lisp</category>
      </categories>
      <tags>
        <tag>lisp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停机问题]]></title>
    <url>%2Fblog%2F2017-01-29-%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[1 停机问题 停机问题wiki 证明过程: 假设存在程序stop?满足以下要求: (stop? prog),如果prog停机返回#t否则返回#f. 定义不停机程序loop (define loop (lambda() (loop))) 构造foo (define foo (lambda() (and (stop? foo) (loop)))) 使用(foo)调用foo程序,首先会对(stop? foo)表达式求值. 假设返回#f(foo不停机),根据and短路求值特性foo程序会直接返回#f从而结束程序(定义说明停机); 假设返回#t(foo停机),则会继续对(loop)求值,(loop)程序会一直运行(定义说明不停机). 两种case都产生矛盾,说明stop?程序不存在.]]></content>
      <categories>
        <category>lisp</category>
      </categories>
      <tags>
        <tag>lisp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android UI 库]]></title>
    <url>%2Fblog%2F2017-01-24-androidlib.html</url>
    <content type="text"><![CDATA[1 android ui lib&#xa0;&#xa0;&#xa0;PERSONAL ui库 TastyToast 炫酷的自定义toast. AdDialog 自定义的广告dialog. Onboarding A beautiful way to introduce users to your app. Android-SpinKit 加载动画库,配备各种加载动画. StickerView A view which can add sticker and zoom,drag,delete it. SlackLoadingView Slack loading animation. RecyclerRefreshLayout A pull to refresh layout for android, the RecyclerRefreshLayout is based on the SwipeRefreshLayout. support all the views, highly customizable, code simplicity, etc ViewPagerCards ViewPager cards. Fresco Facebook open source android picture lib. InstagramLikeColorTransitionAndroid How to create instagram like Gradient color transition in android. AnimShopButton A shopping cart button with a telescopic displacement rotation animation. ViewSpreadTranslationController View Spread TranslationController for Android. Android-SwitchIcon Google launcher-style implementation of switch (enable/disable) icon. PictureSelector Android多图选择器 图片/视频 单选or多选,以及视频录制. Toasty The usual Toast, but with steroids. Hover A floating menu library for Android. 工具库 Sharaku Image filtering UI library like Instagram.]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用hexo搭建个人blog]]></title>
    <url>%2Fblog%2F2015-12-21-buildblogwithhexo.html</url>
    <content type="text"><![CDATA[1 hexo安装 以前陆陆续续用过csdn以及guthub pages写blog.始终没有坚持下来.近两年来一直在 学习eamcs.其中org-mode让我为之倾倒.在工作生活中也都有使用emacs.用过emacs群友 的org-page.但是界面不好看.最后还是放弃.直到遇到hexo和org-octopresss的组合.利 用org-mode进行写作,然后用org-octopress转化成html.搭配hexo的blog框架和漂亮的主 题.一切轻松简单. 关于hexo的介绍可以直接去看文档,开发者是一个台湾人.据说在高中时期就开发了hexo. hexo采用nodejs开发,安装过程和配置都比较简单. npm install -g hexo-cli hexo init &lt;floder&gt; cd &lt;floder&gt; npm install hexo project根目录如下. _config.yml是hexo的站点配置文件,可以配置标题,地区,rss,部署以及评论等功能. # Hexo Configuration ## Docs: http://hexo.io/docs/configuration.html ## Source: https://github.com/hexojs/hexo/ # Site title: Flysands Blog subtitle: Simple is the best description: Keep life stayreal author: Flysands author_title: 'Programmer &amp; Emacser' avatar: css/images/mylogo.jpg location: 'Chengdu, China' follow: https://github.com/chenxs110/ language: zh-CN timezone: since: 2015 # The start year showing in your copyright section. # URL ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/' url: http://chenxs110.github.com # root: / # permalink: :year/:month/:day/:title/ permalink: blog/:year-:month-:day-:title.html permalink_defaults: # Directory source_dir: source public_dir: public tag_dir: tags archive_dir: archives category_dir: categories code_dir: downloads/code i18n_dir: :lang skip_render: # Writing new_post_name: :title.md # File name of new posts default_layout: post titlecase: false # Transform title into titlecase external_link: true # Open external links in new tab filename_case: 0 render_drafts: false post_asset_folder: false relative_link: false future: true highlight: enable: true line_number: true tab_replace: # Category &amp; Tag default_category: uncategorized category_map: tag_map: # Date / Time format ## Hexo uses Moment.js to parse and display date ## You can customize the date format as defined in ## http://momentjs.com/docs/#/displaying/format/ date_format: YYYY-MM-DD time_format: HH:mm:ss # Pagination ## Set per_page to 0 to disable pagination per_page: 6 pagination_dir: page # Extensions ## Plugins: https://github.com/hexojs/hexo/wiki/Plugins plugins: hexo-generator-feed ## Themes: https://github.com/hexojs/hexo/wiki/Themes theme: icarus # Disqus # disqus_shortname: hexo-theme-icarus # DuoShuo duoshuo_shortname: flysands # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: http://github.com/chenxs110/chenxs110.github.io.git branch: master 2 配置主题 hexo的一大优点,就是有很多漂亮的主题.我选择了icarus.并配置了评论插件多说. 3 github pages搭建静态blog 可以参考github配置自己的blog.然后修改hexo站点中的deploy.注意要安装相应的deployer. 我用的是github.所以只需要安装git deployer即可. # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: http://github.com/chenxs110/chenxs110.github.io.git branch: master 安装deployer. npm install hexo-deployer-git --save 如果需要开启rss订阅,需要安装generate-feed插件. npm install hexo-generator-feed --save 并修改config.yml文件添加generate-feed插件. plugins: hexo-generator-feed 在push到仓库之前,需要先执行hexo generate然后再执行hexo deploy进行部署. 4 emacs org-mode写blog 4.1 七牛云存储&amp;hexo交互 写了几个简单函数用来做文件上传以及hexo交互. (defun chenxuesong-qiniu-upload-img (command) (let ((command-str (format "~/Work/dev-tools/qiniu-devtools/qrsync %s" command))) (shell-command-to-string command-str))) (defun chenxuesong-qiniu-achieve-image () (shell-command-to-string "cp -rf ~/Work/blog/images/* ~/Work/blog/images-achieve") (shell-command-to-string "rm -f ~/Work/blog/images/*")) (defun chenxuesong-hexo-generate (args) (interactive "P") (let ((default-directory chenxueosng-blog-dir)) (shell-command-to-string "hexo generate") (message "hexo generate complete."))) (defun chenxuesong-hexo-deploy (args) (interactive "P") (let ((default-directory chenxueosng-blog-dir)) (chenxuesong-qiniu-upload-img (concat chenxueosng-blog-dir "qiniu.json")) (shell-command-to-string "hexo deploy") (chenxuesong-qiniu-achieve-image) (message "hexo deploy complete."))) (defun chenxuesong-insert-qiniu-link (imagename) (interactive "sImage name: ") (insert (concat (format "[[%s%s]]" "http://7xia6k.com1.z0.glb.clouddn.com/" imagename)))) 4.2 org-octopress org-octopress原本是用来把org转化成适合octopress的html文件.由于hexo兼容 octopress.所以也可以用来生成适用于hexo的html文件. 配置如下: (setq org-blog-dir "~/Work/blog/") (setq org-octopress-directory-top org-blog-dir) (setq org-octopress-directory-posts (concat org-blog-dir "source/_posts")) (setq org-octopress-directory-org-top org-blog-dir) (setq org-octopress-directory-org-posts (concat org-blog-dir "blog")) (setq org-octopress-setup-file (concat org-blog-dir "setupfile.org")) 注意org-posts文件夹不能放到source文件中.否则会生成失败. 4.3 快捷键 添加了几个用于发布和转换html的快捷键. (evil-leader/set-key "oc" 'chenxuesong/org-create-org-blog-file) (evil-leader/set-key "op" 'chenxuesong/org-save-and-export) (evil-leader/set-key "od" 'chenxuesong-hexo-deploy) (evil-leader/set-key "og" 'chenxuesong-hexo-generate) (defun chenxuesong-qiniu-upload-img (command) (let ((command-str (format "~/Work/dev-tools/qiniu-devtools/qrsync %s" command))) (shell-command-to-string command-str))) (defun chenxuesong-qiniu-achieve-image () (shell-command-to-string "cp -rf ~/Work/blog/images/* ~/Work/blog/images-achieve") (shell-command-to-string "rm -f ~/Work/blog/images/*")) (defun chenxuesong-hexo-generate (args) (interactive "P") (let ((default-directory chenxueosng-blog-dir)) (shell-command-to-string "hexo generate") (message "hexo generate complete."))) (defun chenxuesong-hexo-deploy (args) (interactive "P") (let ((default-directory chenxueosng-blog-dir)) (chenxuesong-qiniu-upload-img (concat chenxueosng-blog-dir "qiniu.json")) (shell-command-to-string "hexo deploy") (message "hexo deploy complete.")))]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native开发跨平台应用]]></title>
    <url>%2Fblog%2F2015-12-25-react-first.html</url>
    <content type="text"><![CDATA[1 react-native背景 React Native 结合了 Web 应用和 Native 应用的优势,可以使用 JavaScript 来开发 iOS 和 Android 原生应.在 JavaScript 中用 React 抽象操作系统原生的 UI 组件, 代替 DOM 元素来渲染等. React Native 使你能够使用基于 JavaScript 和 React 一致的开发体验在本地平台 上构建世界一流的应用程序体验.React Native 把重点放在所有开发人员关心的平台 的开发效率上.所以开发者只需学习一种语言就能轻易为任何平台高效地编写代码. 2 安装工具集 requirement version xcode ios 7以上 android android build tool 23.0.1以上 nodejs 4.0以上 react-native 0.1.7 我的机器是osx,所以整个安装过程都用brew进行.安装之前建议先更新一下brew. brew update brew upgrade 安装nodejs mac用户直接去官网下载pkg文件安装.注意nodejs版本要高于4.0. 安装watchman brew install watchman 安装flow brew install flow 安装react-native npm install -g react-native-cli 3 第一个跨平台应用 创建过程可以参考帮助文档1. 所有工具集安装完毕后,创建第一个project吧. react-native init your-project-dir project创建成功后会生成ios和android的project目录,以及两个平台的index入口js 文件. run android device cd your-project react-native run-android 查看日志 adb logcat *:S ReactNative:V ReactNativeJS:V 启动成功 run ios 打开ios目录中的xcodeproj文件.点击run按钮即可. 4 使用组件 react-native提供了丰富的native组件. var React = require('react-native'); var { AppRegistry, StyleSheet, Text, View, TextInput,// add text input component } = React; var TestProject = React.createClass({ render: function() { return ( &lt;View style={styles.container}&gt; &lt;Text style={styles.welcome}&gt; Welcome to React Native! &lt;/Text&gt; &lt;Text style={styles.instructions}&gt; To get started, edit index.android.js &lt;/Text&gt; &lt;Text style={styles.instructions}&gt; Shake or press menu button for dev menu &lt;/Text&gt; // add text input &lt;TextInput style={{height: 40, borderColor: 'gray', borderWidth: 1}} onChangeText={(text) =&gt; this.setState({text})} /&gt; &lt;/View&gt; ); } }); 5 问题 安装react-native报警 如果用nvm管理多个node版本.并且安装提示node版本过低.重新下载pkg安装包.安装 即可. run-android报错 react-native android打包工具要23.0.1以上的版本.解决方法是在sdk manager中 安装高版本android build tool. 启动报错 stackoverflow2上有讨论,我在模拟器上执行adb reverse命令做端口映射即可. adb reverse tcp:8081 tcp:8081 6 总结 总的来说开发方式还是便捷许多.但是存在一个普遍问题.跨平台应用开发的通病-性能. Footnotes: 1 react-native doc https://facebook.github.io/react-native/docs/getting-started.html 2 stackoverflow http://stackoverflow.com/questions/32572399/react-native-android-failed-to-load-js-bundle]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>cross-platform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android指纹模块]]></title>
    <url>%2Fblog%2F2016-01-08-android-fingerprint-module.html</url>
    <content type="text"><![CDATA[Table of Contents 1. android指纹模块流程图 2. android setting指纹模块入口 3. nexus 6p无法启用finger问题原因 1 android指纹模块流程图 Tee : trusted excution env 2 android setting指纹模块入口 主要涉及到一下几个文件 packages/apps/Settings/src/com/android/settings/SecuritySettings.java frameworks/base/core/java/android/hardware/fingerprint/FingerprintManager.java frameworks/base/services/core/java/com/android/server/fingerprint/FingerprintService.java frameworks/base/core/java/android/hardware/fingerprint/IFingerprintDaemon.aidl system/core/fingerprintd/IFingerprintDaemon.cpp system/core/fingerprintd/FingerprintDaemonProxy.cpp hardware/libhardware/hardware.c hardware/libhardware/modules/fingerprint/fingerprint.c 具体流程如下: Settings在做页面展示的时候会调用maybeAddFingerprintPreference函数判断是否 添加fingerprint preference. maybeAddFingerprintPreference内部调用FingerprintManager的isHardwareDetected 函数. FingerprintManager调用FingerprintService中的isHardwareDetected函数. FingerprintService中的isHardwareDetected函数首先进行权限检查,然后如果 mDeviceHalId等于0返回false,表示没有检测到指纹相关的硬件.否则返回ture. mDeviceHalId为底层openHal的返回值. openHal函数的实现非常简单,代码片段如下. int64_t FingerprintDaemonProxy::openHal() { ALOG(LOG_VERBOSE, LOG_TAG, "nativeOpenHal()\n"); int err; const hw_module_t *hw_module = NULL; if (0 != (err = hw_get_module(FINGERPRINT_HARDWARE_MODULE_ID, &amp;hw_module))) { ALOGE("Can't open fingerprint HW Module, error: %d", err); return 0; } if (NULL == hw_module) { ALOGE("No valid fingerprint module"); return 0; } mModule = reinterpret_cast&lt;const fingerprint_module_t *&gt;(hw_module); if (mModule-&gt;common.methods-&gt;open == NULL) { ALOGE("No valid open method"); return 0; } hw_device_t *device = NULL; if (0 != (err = mModule-&gt;common.methods-&gt;open(hw_module, NULL, &amp;device))) { ALOGE("Can't open fingerprint methods, error: %d", err); return 0; } if (kVersion != device-&gt;version) { ALOGE("Wrong fp version. Expected %d, got %d", kVersion, device-&gt;version); // return 0; // FIXME } mDevice = reinterpret_cast&lt;fingerprint_device_t *&gt;(device); err = mDevice-&gt;set_notify(mDevice, hal_notify_callback); if (err &lt; 0) { ALOGE("Failed in call to set_notify(), err=%d", err); return 0; } // Sanity check - remove if (mDevice-&gt;notify != hal_notify_callback) { ALOGE("NOTIFY not set properly: %p != %p", mDevice-&gt;notify, hal_notify_callback); } ALOG(LOG_VERBOSE, LOG_TAG, "fingerprint HAL successfully initialized"); return reinterpret_cast&lt;int64_t&gt;(mDevice); // This is just a handle } openHal函数主要实现以下3个功能 调用hw_get_module加载对应的库文件 调用module结构体的common.methods-&gt;open指向的函数 module结构体定义如下 static struct hw_module_methods_t fingerprint_module_methods = { .open = fingerprint_open, }; fingerprint_module_t HAL_MODULE_INFO_SYM = { .common = { .tag = HARDWARE_MODULE_TAG, .module_api_version = FINGERPRINT_MODULE_API_VERSION_2_0, .hal_api_version = HARDWARE_HAL_API_VERSION, .id = FINGERPRINT_HARDWARE_MODULE_ID, .name = "Emulator Fingerprint HAL", .author = "The Android Open Source Project", .methods = &amp;fingerprint_module_methods, }, }; fingerprint_open函数定义如下 static int fingerprint_open(const hw_module_t *module, const char __unused *id, hw_device_t **device) { if (device == NULL) { ALOGE("NULL device on open"); return -EINVAL; } fingerprint_device_t *dev = malloc(sizeof(fingerprint_device_t)); memset(dev, 0, sizeof(fingerprint_device_t)); dev-&gt;common.tag = HARDWARE_DEVICE_TAG; dev-&gt;common.version = FINGERPRINT_MODULE_API_VERSION_2_0; dev-&gt;common.module = (struct hw_module_t *)module; dev-&gt;common.close = fingerprint_close; dev-&gt;pre_enroll = fingerprint_pre_enroll; dev-&gt;enroll = fingerprint_enroll; dev-&gt;get_authenticator_id = fingerprint_get_auth_id; dev-&gt;cancel = fingerprint_cancel; dev-&gt;remove = fingerprint_remove; dev-&gt;set_active_group = fingerprint_set_active_group; dev-&gt;authenticate = fingerprint_authenticate; dev-&gt;set_notify = set_notify_callback; dev-&gt;notify = NULL; *device = (hw_device_t *)dev; return 0; } 调用set_notify设置回调函数 hw_get_module函数主要实现底层so库加载 具体加载过程可以参考android hw_get_module 分析 hw_get_module内部调用hw_get_module_by_class实现加载过程 /** Base path of the hal modules */ #if defined(__LP64__) #define HAL_LIBRARY_PATH1 "/system/lib64/hw" #define HAL_LIBRARY_PATH2 "/vendor/lib64/hw" #else #define HAL_LIBRARY_PATH1 "/system/lib/hw" #define HAL_LIBRARY_PATH2 "/vendor/lib/hw" #endif /** * There are a set of variant filename for modules. The form of the filename * is "&lt;MODULE_ID&gt;.variant.so" so for the led module the Dream variants * of base "ro.product.board", "ro.board.platform" and "ro.arch" would be: * * led.trout.so * led.msm7k.so * led.ARMV6.so * led.default.so */ static const char *variant_keys[] = { "ro.hardware", /* This goes first so that it can pick up a different file on the emulator. */ "ro.product.board", "ro.board.platform", "ro.arch"}; hw_get_module_by_class根据优先级搜索对应的so文件,文件名主要由两部分构成. 第一部分为模块名,第二部分为类型.其中模块名固定,第二部分优先级顺序为: 硬件 &gt; 产品 &gt; cpu &gt; arch &gt; default. 如果以上函数都执行成功,那么fingerprint module则加载完成. 3 nexus 6p无法启用finger问题原因 清华镜像的源码选择angler product,编译出来的system.img里没有fingerprintd可执行文件. 没有加载fingerprint module对应的库文件. hardware so库加载顺序有误. 解决方法 以移植goldfish为例 拷贝device/generic/goldfish/fingerprint目录到device/huawei/angler目录下 修改device/huawei/angler/device.mk文件,添加fingerprint模块 #Fingerprint PRODUCT_PACKAGES += \ fingerprintd \ fingerprint.msm8994 修改模块加载顺序 由于源码编译出来的image文件,在system/vendor/lib64下含有fingerprint.angler.so. 所以在hw_get_module会加载fingerprint.angler.so而忽略fingerprint.msm8994.so. 所以修改hardware.c文件中的默认搜索顺序,把ro.board.platform放到第一即可. static const char *variant_keys[] = { "ro.board.platform", "ro.hardware", /* This goes first so that it can pick up a different file on the emulator. */ "ro.product.board", // "ro.board.platform", "ro.arch"};]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker compose]]></title>
    <url>%2Fblog%2F2016-01-07-docker-compose.html</url>
    <content type="text"><![CDATA[1 compose docke command test command composess tb link]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建私有registry]]></title>
    <url>%2Fblog%2F2016-03-03-private-registry.html</url>
    <content type="text"><![CDATA[1 背景 2 选型 3 Portus 3.1 下载 git clone https://github.com/SUSE/Portus.git 3.2 初次运行 Portus提供了一个体验版本.compose-setup.sh.简单运行即可. compose-setup.sh -e external-ip 脚本很简单,做了一下几件事情. 检查参数和版本 生成两个config文件(根据template文件生成docker-compose.yml和./compose/registry/config.yml) docker-compose启动数据库,portus_web,crono以及registry 初始化数据库 进入external-ip:3000端口 enjoy it! 3.3 Warning shell提示warning.原来用compose-setup部署的版本只能用于开发或者测试. ########### # WARNING # ########### This deployment method is intended for testing/development purposes. To deploy Portus on production please take a look at: http://port.us.org/documentation.html 总结起来有一下几个问题. registry不支持ssl 没有使用ca机构颁发的证书 数据库以及registry data没有持久化 4 Production部署 部署生产环境的私有registry,需要以下三个模块相辅相成.主要是设置证书和registry以及持久化. 4.1 替换证书 docker-compose.yml指定了registry使用的证书.该证书存放于容器中/etc/docker/registry/目录下. cd Portus mkdir certs cp your-ca.crt xxxx.crt cp your-ca.key xxxx.key xxxx替换为你自己想要定义的名字. 4.2 生成挂载文件夹 cd Portus cd .. mkdir portusdb mkdir registry_data 4.3 Portus web 由于替换了registry使用的证书.所以Portus web也要使用配对的key文件. 在docker-compose.yml中添加环境变量 PORTUS_KEY_PATH. 4.4 Registry 测试版本的部署,没有使用持久化以及tls.持久化需要在docker-compose.yml中配置, tls在./compose/registry/config.yml中配置.配置好的config.yml如下. version: 0.1 storage: filesystem: rootdirectory: /registry_data delete: enabled: true http: addr: 0.0.0.0:5000 debug: addr: 0.0.0.0:5001 tls: certificate: /certs/xxxx.crt key: /certs/xxxx.key auth: token: realm: http:/your-host/registry.testbird.com:3000/v2/token service: your-host:5000 issuer: your-host rootcertbundle: /etc/docker/registry/xxxx.crt notifications: endpoints: - name: portus url: http://your-host:3000/v2/webhooks/events timeout: 500ms threshold: 5 backoff: 1s 4.5 Database 数据库使用mariadb.根据官方文档,持久化储存只需要挂载一个文件夹到容器的/var/lib/mysql 文件夹即可./var/lib/mysql为mariadb的默认db路径.参见docker-compose.yml. 4.6 docker-compose.yml web: image: portus_web command: puma -b tcp://0.0.0.0:3000 -w 3 environment: - PORTUS_MACHINE_FQDN_VALUE=your-host - PORTUS_DB_HOST=portus_db_1 - PORTUS_KEY_PATH=certs/xxxx.key volumes: - .:/portus ports: - 3000:3000 links: - db crono: image: portus_web entrypoint: bin/crono environment: - PORTUS_MACHINE_FQDN=your-host - PORTUS_DB_HOST=portus_db_1 volumes: - .:/portus links: - db db: image: library/mariadb:10.0.23 environment: MYSQL_ROOT_PASSWORD: portus volumes: - ../portusdb:/var/lib/mysql registry: image: library/registry:2.1.1 volumes: - ./certs:/certs - ../registry_data:/registry_data - ./certs/xxxx.crt:/etc/docker/registry/xxxx.crt:ro - ./compose/registry/config.yml:/etc/docker/registry/config.yml:ro ports: - 5000:5000 - 5001:5001 # required to access debug service links: - web 4.7 相关命令 #&#21551;&#21160; cd Portus docker-compose up -d #&#20572;&#27490; docker-compose kill #&#21024;&#38500; docker-compose rm -fv 4.8 初始化数据库 第一次启动后,需要执行两个rake命令初始化数据库. #&#36827;&#20837;web&#23481;&#22120; docker exec -it xxx /bin/sh docker-compose run --rm web rake db:migrate:reset &gt; /dev/null docker-compose run --rm web rake db:seed &gt; /dev/null]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Testbird ci 2.0]]></title>
    <url>%2Fblog%2F2016-03-08-testbird-ci-env.html</url>
    <content type="text"><![CDATA[1 Testbird ci 2.0 流程图 2 参与者 TbCli testbird devops开发用于ci过程的项目代码. Gitlab 不多介绍. Jenkins 不多介绍. Registry testbird自建docker registry. Ansible 运维发布工具. Kubernetes 容器编排工具.]]></content>
      <categories>
        <category>devops</category>
      </categories>
      <tags>
        <tag>devops</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[malawi-cichlids]]></title>
    <url>%2Fblog%2F2016-03-16-malawi-cichlids.html</url>
    <content type="text"><![CDATA[Table of Contents 1. Buccochromis 1.1. Buccochromis spectabilis (新马头) 2. Champsochromis 2.1. Champsochromis caeruleus (酷斯拉) 3. Ctenopharynx 3.1. Ctenopharynx nitidus (金三角) 4. Dimidiochromis 4.1. Dimidiochromis compressiceps (蓝马面) 5. Fossorochromis 5.1. Fossorochromis rostratus (雪花豹) 6. Mylochromis 6.1. Mylochromis ensatus (1280火箭) 6.2. Mylochromis melanotaenia (金斜间) 7. Otopharynx 7.1. Otopharynx heterodon "Tanzanie" (大粒墨) 7.2. Otopharynx lithobates (金头蓝孔雀) 8. Protomelas 8.1. Protomelas fenestratus "Magunga" (史提芬) 8.2. Protomelas taeniolatus (埃及艳后) 9. Placidochromis 9.1. Placidochromis phenochilus (白嘴蓝宝石) 10. Tyrannochromis 10.1. Tyrannochromis macrostoma (大口鲷) 11. Stigmatochromis 11.1. Stigmatochromis woodi (乌帝鹰) 12. Nimbochromis 12.1. Nimbochromis polystigma (芝麻斑) 13. All 14. Reference 学名 中文名 状况 尺寸 价格 公母 品系 数目 Aristochromis christyi 鸟嘴 发色 17-20 200 公 野生 1 Hemitaeniochromis urotaenia 巨人马面 发色 13-15 200 公 野生 1 Aulonocara steveni Chiwindi 蓝黎明 阵亡 10-12 200 公 野生 1 Aulonocara steveni Chiwindi 蓝黎明 阵亡 8-10 60 公 人工 1 Aulonocara steveni Chiwindi 蓝黎明 发色 8-10 80 公 人工 1 Aulonocara baenschi 金松鼠 发色 10-12 70 公 人工 1 Copadichromis borleyi "Mbenji" 波里尔 发色 10-12 200 公 野生 1 Copadichromis trimaculatus 血艳红 发色 8-10 35 公 人工 1 Chilotilapia rhoadesii 帝王鲷 发色 8-10 50 公 人工 1 Buccochromis lepturus 绿马头 良好 8-10 100 公 人工 1 Buccochromis spectabilis 新马头 出售 13-15 520 公 野生 1 Buccochromis spectabilis 新马头 良好 11-13 50 公 人工 1 Buccochromis spectabilis 新马头 良好 8-10 80 公 人工 1 Buccochromis nototaenia 金火令 良好 10-13 100 公 人工 1 Buccochromis nototaenia 金火令 阵亡 8-9 70 公 人工 1 Champsochromis caeruleus 酷斯拉 阵亡 16-18 450 公 野生 1 Copadichromis azureus 金属蓝 良好 10-13 60 公 人工 1 Ctenopharynx nitidus 金三角 良好 13-15 400 公 野生 1 Dimidiochromis compressiceps 蓝马面 阵亡 15-17 100 公 人工 1 Exochochromis anagenys 金鹰 阵亡 6-8 80 公 人工 1 Fossorochromis rostratus 雪花豹 良好 12-13 200 母 野生 1 Fossorochromis rostratus 雪花豹 发色 15-17 330 公 野生 1 Lethrinops Micrentodon Makokola 太阳珍珠 阵亡 5-7 60 公 人工 1 Hemitilapia oxyrhyncha 鸭嘴倒三角 阵亡 13-15 450 公 野生 1 Mylochromis ensatus 1280火箭 阵亡 10-12 288 公 野生 1 Mylochromis melanotaenia 金斜间 阵亡 7-9 200 公 野生 1 Otopharynx heterodon "Tanzanie" 大粒墨 完美 12-13 288 公 野生 1 Otopharynx lithobates 金头蓝孔雀 阵亡 8-9 120 公 德系 1 Protomelas fenestratus "Magunga" 史提芬 阵亡 10-12 260 公 野生 1 Protomelas taeniolatus 埃及艳后 阵亡 13-15 100 公 人工 1 Protomelas taeniolatus 埃及艳后 良好 13-15 0 公 人工 1 Placidochromis phenochilus Mdoka white 白嘴蓝宝石 良好 13-15 150 公 人工 1 Placidochromis phenochilus Mdoka white 白嘴蓝宝石 送人 13-15 150 公 人工 1 Placidochromis phenochilus 蓝宝石 良好 8-9 60 公 人工 1 Tyrannochromis macrostoma 大口鲷 良好 15-17 300 公 野生 1 Tyrannochromis macrostoma "Likoma" 大口鲷 发色 20-22 0 公 野生 1 Stigmatochromis modestus 冇得死 发色 12-15 400 公 野生 1 Stigmatochromis woodi 乌帝鹰 阵亡 13-15 240 公 野生 1 Nimbochromis polystigma 芝麻斑 良好 13-15 400 公 野生 1 &#xa0; &#xa0; &#xa0; &#xa0; 7021 &#xa0; &#xa0; 38 1 Buccochromis 1.1 Buccochromis spectabilis (新马头) 2 Champsochromis 2.1 Champsochromis caeruleus (酷斯拉) 3 Ctenopharynx 3.1 Ctenopharynx nitidus (金三角) 4 Dimidiochromis 4.1 Dimidiochromis compressiceps (蓝马面) 5 Fossorochromis 5.1 Fossorochromis rostratus (雪花豹) 6 Mylochromis 6.1 Mylochromis ensatus (1280火箭) 6.2 Mylochromis melanotaenia (金斜间) 7 Otopharynx 7.1 Otopharynx heterodon "Tanzanie" (大粒墨) 7.2 Otopharynx lithobates (金头蓝孔雀) 8 Protomelas 8.1 Protomelas fenestratus "Magunga" (史提芬) 8.2 Protomelas taeniolatus (埃及艳后) 9 Placidochromis 9.1 Placidochromis phenochilus (白嘴蓝宝石) 10 Tyrannochromis 10.1 Tyrannochromis macrostoma (大口鲷) 11 Stigmatochromis 11.1 Stigmatochromis woodi (乌帝鹰) 12 Nimbochromis 12.1 Nimbochromis polystigma (芝麻斑) 13 All 14 Reference onzemalawicichliden malawi-info malawicichlids]]></content>
      <categories>
        <category>cichlid</category>
      </categories>
      <tags>
        <tag>cichlid</tag>
        <tag>pet</tag>
      </tags>
  </entry>
</search>
